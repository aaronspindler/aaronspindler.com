# Generated by Django 5.2.7 on 2025-10-15 18:49
"""
IP Address Normalization Migration

This migration normalizes IP address storage by creating a separate IPAddress model.

Before:
    RequestFingerprint stores IP as GenericIPAddressField with geo_data JSONField
    - Duplicate geo_data for same IP across multiple requests
    - Example: 1000 requests from 50 IPs = 1000 geo_data copies

After:
    IPAddress model stores unique IPs with their geo_data (one copy per IP)
    RequestFingerprint has ForeignKey to IPAddress
    - Single geo_data per IP, shared across all requests
    - Example: 1000 requests from 50 IPs = 50 geo_data copies

Benefits:
    - Reduced storage (95%+ for geo_data)
    - Efficient geolocation updates (update 1 IP vs N requests)
    - Better data normalization
    - Backward compatible via @property

Performance:
    - Uses bulk_create for IPAddress records (~500 records/second)
    - Single query to fetch geo_data map
    - Batch updates for linking
    - Expected time: ~1-5 seconds for 1000 IPs
"""

import time

import django.db.models.deletion
from django.db import migrations, models


def migrate_ip_addresses_forward(apps, schema_editor):
    """
    Migrate IP addresses and geo_data from RequestFingerprint to IPAddress model.

    Creates IPAddress records for each unique IP and links RequestFingerprints to them.
    Optimized to use bulk operations and minimize database queries.
    """
    start_time = time.time()

    RequestFingerprint = apps.get_model("utils", "RequestFingerprint")
    IPAddress = apps.get_model("utils", "IPAddress")

    # Get all unique IP addresses from RequestFingerprint
    unique_ips = list(RequestFingerprint.objects.values_list("ip_address", flat=True).distinct())
    total_ips = len(unique_ips)
    total_fingerprints = RequestFingerprint.objects.count()

    print(f"\n{'='*70}")
    print(f"IP Address Normalization Migration")
    print(f"{'='*70}")
    print(f"üìä Total RequestFingerprint records: {total_fingerprints}")
    print(f"üìç Unique IP addresses to migrate: {total_ips}")
    if total_ips > 0 and total_fingerprints > 0:
        reduction = ((total_fingerprints - total_ips) / total_fingerprints * 100)
        print(f"üíæ Estimated storage reduction: {reduction:.1f}%")
    print(f"{'='*70}\n")

    if total_ips == 0:
        print("‚úÖ No IP addresses to migrate")
        return

    # Step 1: Build a map of IP -> geo_data (one query instead of N queries)
    print("üìã Step 1/3: Building geo_data map...")
    ip_to_geo_data = {}
    fingerprints_with_geo = RequestFingerprint.objects.filter(
        geo_data__isnull=False
    ).values("ip_address", "geo_data").distinct()

    for fp in fingerprints_with_geo:
        if fp["ip_address"] not in ip_to_geo_data:
            ip_to_geo_data[fp["ip_address"]] = fp["geo_data"]

    print(f"   Found {len(ip_to_geo_data)} IP(s) with existing geo_data")

    # Step 2: Bulk create IPAddress records
    print("\nüèóÔ∏è  Step 2/3: Creating IPAddress records...")
    ip_address_objs = []
    for idx, ip_str in enumerate(unique_ips, 1):
        geo_data = ip_to_geo_data.get(ip_str, None)
        ip_address_objs.append(
            IPAddress(
                ip_address=ip_str,
                geo_data=geo_data,
            )
        )

        # Show progress every 100 IPs
        if idx % 100 == 0 or idx == total_ips:
            print(f"   Creating IPAddress records: {idx}/{total_ips} ({idx/total_ips*100:.1f}%)")

    # Bulk create all IPAddress records at once (much faster than one-by-one)
    IPAddress.objects.bulk_create(ip_address_objs, batch_size=500, ignore_conflicts=True)
    print(f"   ‚úÖ Created {total_ips} IPAddress records")

    # Step 3: Link RequestFingerprints to their IPAddress records
    print("\nüîó Step 3/3: Linking RequestFingerprints to IPAddress records...")

    # Use raw SQL for maximum performance (single UPDATE with subquery)
    # This is MUCH faster than looping through IPs
    print("   Executing bulk link operation...")

    db_alias = schema_editor.connection.alias
    with schema_editor.connection.cursor() as cursor:
        # Update all RequestFingerprints in a single query using a JOIN
        cursor.execute(
            """
            UPDATE utils_requestfingerprint rf
            SET ip_address_new_id = (
                SELECT id FROM utils_ipaddress ip
                WHERE ip.ip_address = rf.ip_address
            )
            WHERE rf.ip_address_new_id IS NULL
            """
        )
        linked_count = cursor.rowcount

    print(f"   ‚úÖ Linked {linked_count} RequestFingerprint records in single query")

    # Verify all RequestFingerprints have been linked
    unlinked = RequestFingerprint.objects.filter(ip_address_new__isnull=True).count()
    if unlinked > 0:
        print(f"\n‚ö†Ô∏è  WARNING: {unlinked} RequestFingerprint(s) were not linked!")
        print("   This may indicate data inconsistency. Migration will continue.")
    else:
        print(f"   ‚úÖ Verification passed: All fingerprints linked")

    elapsed_time = time.time() - start_time

    print(f"\n{'='*70}")
    print(f"‚úÖ Migration Complete!")
    print(f"{'='*70}")
    print(f"üìä Created {total_ips} IPAddress records")
    print(f"üîó Linked {linked_count} RequestFingerprint records")
    print(f"üíæ Migrated geo_data for {len(ip_to_geo_data)} IP addresses")
    print(f"‚è±Ô∏è  Total time: {elapsed_time:.2f} seconds")
    if total_ips > 0:
        print(f"‚ö° Average: {elapsed_time/total_ips*1000:.2f}ms per IP")
    print(f"{'='*70}\n")


def migrate_ip_addresses_backward(apps, schema_editor):
    """
    Reverse migration: copy geo_data from IPAddress back to RequestFingerprint.

    WARNING: This will duplicate geo_data across all RequestFingerprints.
    """
    start_time = time.time()

    RequestFingerprint = apps.get_model("utils", "RequestFingerprint")

    total_fingerprints = RequestFingerprint.objects.count()

    print(f"\n{'='*70}")
    print(f"Reversing IP Address Normalization")
    print(f"{'='*70}")
    print(f"üìä Processing {total_fingerprints} RequestFingerprint records")
    print(f"‚ö†Ô∏è  WARNING: This will duplicate geo_data storage")
    print(f"{'='*70}\n")

    if total_fingerprints == 0:
        print("‚úÖ No records to reverse")
        return

    print("üîÑ Copying IP addresses and geo_data back to RequestFingerprint...")

    # Batch update using select_related to minimize queries
    batch_size = 500
    processed = 0

    for fingerprint in RequestFingerprint.objects.select_related("ip_address_new").iterator(chunk_size=batch_size):
        if fingerprint.ip_address_new:
            # Copy IP address string back
            fingerprint.ip_address = fingerprint.ip_address_new.ip_address

            # Copy geo_data back if it exists
            if fingerprint.ip_address_new.geo_data:
                fingerprint.geo_data = fingerprint.ip_address_new.geo_data

            fingerprint.save()
            processed += 1

            # Show progress every 100 records
            if processed % 100 == 0:
                print(f"   Progress: {processed}/{total_fingerprints} ({processed/total_fingerprints*100:.1f}%)")

    elapsed_time = time.time() - start_time

    print(f"\n{'='*70}")
    print(f"‚úÖ Reverse Migration Complete!")
    print(f"{'='*70}")
    print(f"üìä Processed {processed} RequestFingerprint records")
    print(f"‚è±Ô∏è  Total time: {elapsed_time:.2f} seconds")
    print(f"{'='*70}\n")


class Migration(migrations.Migration):

    dependencies = [
        ("utils", "0006_add_geo_data_to_requestfingerprint"),
    ]

    operations = [
        # Step 1: Create IPAddress model
        migrations.CreateModel(
            name="IPAddress",
            fields=[
                (
                    "id",
                    models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID"),
                ),
                ("ip_address", models.GenericIPAddressField(db_index=True, unique=True)),
                (
                    "geo_data",
                    models.JSONField(
                        blank=True,
                        help_text="Geographic location data for IP address (city, country, lat/lon, etc.)",
                        null=True,
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
            ],
            options={
                "verbose_name": "IP Address",
                "verbose_name_plural": "IP Addresses",
                "ordering": ["-created_at"],
            },
        ),
        # Step 2: Add temporary new FK field (nullable for migration)
        migrations.AddField(
            model_name="requestfingerprint",
            name="ip_address_new",
            field=models.ForeignKey(
                null=True,
                blank=True,
                help_text="IP address (with shared geolocation data)",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="request_fingerprints",
                to="utils.ipaddress",
            ),
        ),
        # Step 3: Migrate data from old ip_address to IPAddress model
        migrations.RunPython(migrate_ip_addresses_forward, reverse_code=migrate_ip_addresses_backward),
        # Step 4: Remove old fields
        migrations.RemoveField(
            model_name="requestfingerprint",
            name="ip_address",
        ),
        migrations.RemoveField(
            model_name="requestfingerprint",
            name="geo_data",
        ),
        # Step 5: Rename ip_address_new to ip_address and make it required
        migrations.RenameField(
            model_name="requestfingerprint",
            old_name="ip_address_new",
            new_name="ip_address",
        ),
        migrations.AlterField(
            model_name="requestfingerprint",
            name="ip_address",
            field=models.ForeignKey(
                help_text="IP address (with shared geolocation data)",
                on_delete=django.db.models.deletion.CASCADE,
                related_name="request_fingerprints",
                to="utils.ipaddress",
            ),
        ),
    ]
