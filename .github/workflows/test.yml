name: Pipeline - Tests

run-name: "${{ github.event.head_commit.message || github.event.pull_request.title || 'Run Tests' }}"

on:
  push:
    branches: [ 'main' ]  # Only run on direct pushes to main
    paths-ignore:  # Skip workflow for documentation-only changes
      - '**.md'
      - 'docs/**'
      - '.cursor/**'
      - 'LICENSE'
      - '.gitignore'
  pull_request:
    branches: [ '**' ]  # Run on all PRs
    types: [ opened, synchronize, reopened, ready_for_review ]
    paths-ignore:  # Skip workflow for documentation-only changes
      - '**.md'
      - 'docs/**'
      - '.cursor/**'
      - 'LICENSE'
      - '.gitignore'
  workflow_dispatch:

# Cancel in-progress test runs for fast feedback
# Prevents resource contention by limiting concurrent workflow runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SECRET_KEY: "FAKE_SECRET_KEY"
  PYTHONUNBUFFERED: 1
  DOCKER_IMAGE_NAME: test-runner
  REGISTRY: ghcr.io
  TEST_COMPOSE_FILES: -f deployment/docker-compose.test.yml -f deployment/docker-compose.test.ci.yml
  # Phase 2 Optimization: Registry-based image distribution
  # Use unique tag per workflow run for parallel pulls across jobs
  TEST_IMAGE_TAG: test-${{ github.run_id }}
  # Cache versions - bump these to invalidate caches
  PIP_CACHE_VERSION: v1
  DOCKER_CACHE_VERSION: v2

permissions:
  contents: read
  packages: write  # Required for pushing test images to GHCR

jobs:
  # Phase 2 Optimization: Build and push test image to GHCR for fast parallel distribution
  # This eliminates 30-48 minutes of artifact download time across all test jobs
  # Registry pulls are much faster than artifact downloads and support layer caching
  build-docker-image:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      packages: write  # Required for pushing test images to GHCR
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      # Note: Buildx setup is intentionally duplicated across jobs for job isolation
      # Each job needs its own Buildx instance to run independently and in parallel
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:buildx-stable-1
          # Phase 3: Enable BuildKit features for cache mounts
          buildkitd-flags: --allow-insecure-entitlement security.insecure --allow-insecure-entitlement network.host

      - name: Verify Docker Compose file
        run: |
          if [ ! -f deployment/docker-compose.test.yml ]; then
            echo "‚ùå deployment/docker-compose.test.yml not found!"
            exit 1
          fi
          echo "‚úÖ deployment/docker-compose.test.yml found"

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Removed verbose diagnostic output - keeping build process streamlined

      - name: Build and push test image to GHCR
        id: bake
        uses: docker/bake-action@3acf805d94d93a86cce4ca44798a76464a75b88c  # v5.10.0
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_PREFIX: ${{ github.repository }}
          TAG: ${{ env.TEST_IMAGE_TAG }}  # Use the unique run ID tag
          # Phase 3: Enable BuildKit cache mounts for package managers
          DOCKER_BUILDKIT: 1
          BUILDKIT_INLINE_CACHE: 1
        with:
          files: deployment/docker-bake.multistage.hcl
          targets: test
          push: true
          set: |
            *.cache-from=type=registry,ref=${{ env.REGISTRY }}/${{ github.repository }}/cache:test
            *.cache-from=type=gha,scope=buildx-test-${{ env.DOCKER_CACHE_VERSION }}
            *.cache-to=type=registry,ref=${{ env.REGISTRY }}/${{ github.repository }}/cache:test,mode=max
            *.cache-to=type=gha,mode=max,scope=buildx-test-${{ env.DOCKER_CACHE_VERSION }}

  # Build production images in parallel with tests (push with temp tag)
  build-production-images:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 8
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:buildx-stable-1
          buildkitd-flags: --allow-insecure-entitlement security.insecure --allow-insecure-entitlement network.host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push production images with temporary tag
        uses: docker/bake-action@3acf805d94d93a86cce4ca44798a76464a75b88c  # v5.10.0
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_PREFIX: ${{ github.repository }}
          TAG: build-${{ github.run_id }}
          DOCKER_BUILDKIT: 1
          BUILDKIT_INLINE_CACHE: 1
        with:
          files: deployment/docker-bake.multistage.hcl
          targets: essential
          push: true
          set: |
            *.cache-from=type=registry,ref=${{ env.REGISTRY }}/${{ github.repository }}/cache:prod
            *.cache-from=type=gha,scope=buildx-prod-${{ env.DOCKER_CACHE_VERSION }}
            *.cache-to=type=registry,ref=${{ env.REGISTRY }}/${{ github.repository }}/cache:prod,mode=max
            *.cache-to=type=gha,mode=max,scope=buildx-prod-${{ env.DOCKER_CACHE_VERSION }}
          provenance: false
          sbom: false

  test-suite:
    runs-on: ubuntu-latest
    needs: build-docker-image
    timeout-minutes: 10
    permissions:
      contents: read
      packages: read  # Required for pulling test images from GHCR
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull test image from GHCR
        run: |
          docker pull ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TEST_IMAGE_TAG }}
          docker tag ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TEST_IMAGE_TAG }} ${{ env.DOCKER_IMAGE_NAME }}:latest
          echo "‚úÖ Image ready"

      - name: Start services
        run: |
          echo "Starting database services..."
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          docker compose $COMPOSE up -d postgres redis questdb

          # Services will automatically wait for health checks due to depends_on configuration
          echo "‚úÖ All services are healthy and ready"

      - name: Run Django checks
        run: |
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          echo "Running migrations check..."
          docker compose $COMPOSE run --rm test_runner \
            python manage.py makemigrations --check --dry-run --settings=config.settings_test

          echo "Running system check..."
          docker compose $COMPOSE run --rm test_runner \
            python manage.py check --deploy --settings=config.settings_test

          echo "‚úÖ Django checks passed"

      - name: Run all tests
        run: |
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          mkdir -p ./test_output

          docker compose $COMPOSE run --rm \
            -v $(pwd)/test_output:/code/test_output \
            -v $(pwd)/pyproject.toml:/code/pyproject.toml:ro \
            test_runner sh -c "
            pip install unittest-xml-reporting pytest-json-report --root-user-action=ignore &&
            export PYTHONDONTWRITEBYTECODE=1 &&
            export PYTHONUNBUFFERED=1 &&
            export COVERAGE_RCFILE=/code/pyproject.toml &&
            export TEST_OUTPUT_DIR=/code/test_output/test-results &&
            coverage run manage.py test accounts config pages utils blog photos \
              --settings=config.settings_test \
              --no-input \
              --verbosity=2 \
              --timing &&
            coverage report &&
            coverage xml -o /code/test_output/coverage.xml
          "

          echo "‚úÖ All tests completed"

      - name: Upload coverage artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        with:
          name: coverage
          path: ./test_output/coverage.xml
          retention-days: 1

      - name: Upload test results artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        with:
          name: test-results
          path: ./test_output/test-results/
          retention-days: 1

      - name: Cleanup
        if: always()
        run: |
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          docker compose $COMPOSE down -v
          echo "‚úÖ Cleanup complete"

  # Coverage upload runs in parallel and doesn't block deployment
  # Coverage is informational - tests already passed, this just reports metrics
  coverage-upload:
    runs-on: ubuntu-latest
    needs: test-suite
    if: needs.test-suite.result == 'success'  # Only upload coverage when tests succeed
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Download coverage artifact
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: coverage
          path: ./

      - name: Download test results artifact
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: test-results
          path: ./test-results

      - name: Upload to Codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7  # v5.5.1
        with:
          files: ./coverage.xml
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload test results to Codecov
        uses: codecov/test-results-action@v1  # v1.1.1
        with:
          files: ./test-results/**/*.xml
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}


  # Final check to ensure all jobs passed (gate before tagging images)
  # Coverage upload runs in parallel and doesn't block this check
  all-checks:
    runs-on: ubuntu-latest
    needs: [build-docker-image, test-suite]
    if: always()
    steps:
      - name: Check if all jobs passed
        run: |
          BUILD_STATUS="${{ needs.build-docker-image.result }}"
          if [[ "$BUILD_STATUS" != "success" ]]; then
            echo "‚ùå Docker build failed (status: $BUILD_STATUS)"
            exit 1
          fi

          TEST_STATUS="${{ needs.test-suite.result }}"
          if [[ "$TEST_STATUS" != "success" ]]; then
            echo "‚ùå Test suite failed (includes Django checks + tests) (status: $TEST_STATUS)"
            exit 1
          fi

          # Production build status is checked in tag-production-images job
          # We don't need to block here - let builds finish in parallel

          echo "‚úÖ All checks passed successfully!"
          echo ""
          echo "üöÄ OPTIMIZATIONS ACTIVE:"
          echo "  Phase 1: pip cache + health checks + rebalancing (8-12 min savings)"
          echo "  Phase 2: GHCR registry distribution (30-48 min savings)"
          echo "  Phase 3: BuildKit cache + timing data (5-10 min savings)"
          echo "  Phase 4: DisableMigrations + removed sleep (2-3 min savings)"
          echo ""
          echo "üìä CUMULATIVE SAVINGS:"
          echo "  TOTAL: 45-73 minutes saved (from ~45min baseline)"
          echo "  Target runtime: ~23-27 minutes (48% reduction)"

  # Re-tag production images with final SHA tag after all checks pass
  # Uses docker buildx imagetools for fast manifest copying (no rebuild or re-push)
  tag-production-images:
    runs-on: ubuntu-latest
    needs: [all-checks, build-production-images]
    if: github.ref == 'refs/heads/main' && needs.all-checks.result == 'success'
    timeout-minutes: 5
    permissions:
      contents: read
      packages: write
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Re-tag essential production images with commit SHA
        run: |
          # Re-tag only essential images (web + celery-unified) for faster completion
          for service in web celery; do
            docker buildx imagetools create \
              --tag ${{ env.REGISTRY }}/${{ github.repository }}-${service}:${{ github.sha }} \
              ${{ env.REGISTRY }}/${{ github.repository }}-${service}:build-${{ github.run_id }} &
          done
          wait
          echo "‚úÖ Essential images re-tagged with commit SHA"

  # Cleanup old test images from GHCR to avoid storage bloat
  # Keeps only the last 10 test images (sufficient for debugging recent runs)
  cleanup-test-images:
    runs-on: ubuntu-latest
    needs: [all-checks]
    if: always() && (github.ref == 'refs/heads/main' || github.event_name == 'pull_request')
    timeout-minutes: 5
    permissions:
      packages: write
    steps:
      - name: Delete old test images
        uses: actions/delete-package-versions@v5
        with:
          package-name: '${{ github.event.repository.name }}/test-runner'
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'false'
        continue-on-error: true  # Don't fail workflow if cleanup fails
