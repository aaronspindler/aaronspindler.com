name: CI - Tests

run-name: "${{ github.event.head_commit.message || github.event.pull_request.title || 'Run Tests' }}"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ opened, synchronize, reopened, ready_for_review ]
  workflow_dispatch:

# Cancel in-progress test runs for fast feedback
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SECRET_KEY: "FAKE_SECRET_KEY"
  PYTHONUNBUFFERED: 1
  DOCKER_IMAGE_NAME: test-runner
  REGISTRY: ghcr.io

permissions:
  contents: read

jobs:
  # Build Docker image once and share it with other jobs
  build-docker-image:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      packages: read
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1
        with:
          driver-opts: |
            network=host

      - name: Verify Docker Compose file
        run: |
          if [ ! -f deployment/docker-compose.test.yml ]; then
            echo "‚ùå deployment/docker-compose.test.yml not found!"
            exit 1
          fi
          echo "‚úÖ deployment/docker-compose.test.yml found"

      - name: Build Docker image with Bake
        uses: docker/bake-action@a4d7f0b5b91c14a296d792d4ec53a9db17f02e67  # v5.10.0
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_PREFIX: ${{ github.repository }}
          TAG: test
        with:
          files: deployment/docker-bake.hcl
          targets: test
          load: true

      - name: Save Docker image to file with optimized compression
        run: |
          sudo apt-get update && sudo apt-get install -y pigz
          docker save ${{ env.DOCKER_IMAGE_NAME }}:latest | pigz -6 > test-runner-image.tar.gz
          echo "üì¶ Compressed image size: $(du -h test-runner-image.tar.gz | cut -f1)"
          echo "Available images:"
          docker images | grep test-runner || true

      - name: Upload Docker image as artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.2
        with:
          name: docker-image
          path: test-runner-image.tar.gz
          retention-days: 1
          compression-level: 0  # Already compressed with pigz

  # Build production images in parallel with tests (cached, not pushed until all tests pass)
  build-production-images:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1
        with:
          driver-opts: |
            network=host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build production images (cache only, don't push)
        uses: docker/bake-action@a4d7f0b5b91c14a296d792d4ec53a9db17f02e67  # v5.10.0
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_PREFIX: ${{ github.repository }}
          TAG: ${{ github.sha }}
        with:
          files: deployment/docker-bake.hcl
          targets: production
          push: false
          set: |
            *.cache-to=type=gha,mode=max,scope=prod-${{ github.sha }}
            *.cache-from=type=gha,scope=prod-${{ github.sha }}
            *.cache-from=type=gha
          provenance: false
          sbom: false

  pre-commit-checks:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0

      - name: Set up Python
        uses: actions/setup-python@bba65e51ff35d50c6dbaaacd8a4681db13aa7cb4  # v6.0.0
        with:
          python-version: '3.12.2'
          cache: 'pip'

      - name: Install pre-commit
        run: |
          python -m pip install --upgrade pip
          pip install pre-commit

      - name: Cache pre-commit environments
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830  # v4.3.0
        with:
          path: ~/.cache/pre-commit
          key: pre-commit-${{ runner.os }}-${{ hashFiles('.pre-commit-config.yaml') }}
          restore-keys: |
            pre-commit-${{ runner.os }}-

      - name: Run pre-commit on all files
        run: |
          pre-commit run --all-files --show-diff-on-failure
        continue-on-error: true

  django-checks:
    runs-on: ubuntu-latest
    needs: build-docker-image
    timeout-minutes: 10
    strategy:
      matrix:
        check: [migrations, system]
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0

      - name: Download Docker image artifact
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0  # v5.0.0
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image with optimized decompression
        run: |
          echo "Loading Docker image..."
          sudo apt-get update && sudo apt-get install -y pigz
          pigz -dc /tmp/test-runner-image.tar.gz | docker load
          docker images | grep test-runner
          sed -i 's|build: \.|image: test-runner:latest|g' deployment/docker-compose.test.yml

      - name: Start required services
        run: |
          docker compose -f deployment/docker-compose.test.yml up -d postgres redis
          echo "Waiting for services to be healthy..."
          timeout 60s bash -c 'until docker compose -f deployment/docker-compose.test.yml ps --format json | grep -q "\"Health\":\"healthy\""; do echo "Waiting for services..."; sleep 2; done' || echo "Warning: Services health check timed out"

      - name: Run Django ${{ matrix.check }} check
        run: |
          case "${{ matrix.check }}" in
            migrations)
              docker compose -f deployment/docker-compose.test.yml run --rm test_runner \
                python manage.py makemigrations --check --dry-run --settings=config.settings_test
              ;;
            system)
              docker compose -f deployment/docker-compose.test.yml run --rm test_runner \
                python manage.py check --deploy --settings=config.settings_test
              ;;
          esac

      - name: Cleanup
        if: always()
        run: docker compose -f deployment/docker-compose.test.yml down -v

  test-suite:
    runs-on: ubuntu-latest
    needs: build-docker-image
    timeout-minutes: 30  # Increased timeout for memory-intensive tests
    strategy:
      fail-fast: false
      matrix:
        test-group:
          - name: "core"
            apps: "accounts pages config"
          - name: "blog"
            apps: "blog"
          - name: "photos"
            apps: "photos"
          - name: "utils"
            apps: "utils"
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0

      - name: Download Docker image artifact
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0  # v5.0.0
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image with optimized decompression
        run: |
          echo "Loading Docker image..."
          sudo apt-get update && sudo apt-get install -y pigz
          pigz -dc /tmp/test-runner-image.tar.gz | docker load
          docker images | grep test-runner
          sed -i 's|build: \.|image: test-runner:latest|g' deployment/docker-compose.test.yml

      - name: Start test services
        run: |
          docker compose -f deployment/docker-compose.test.yml up -d postgres redis
          echo "Waiting for services to be healthy..."
          timeout 60s bash -c 'until docker compose -f deployment/docker-compose.test.yml ps --format json | grep -q "\"Health\":\"healthy\""; do echo "Waiting for services..."; sleep 2; done' || echo "Warning: Services health check timed out"

      - name: Run tests for ${{ matrix.test-group.name }}
        run: |
          mkdir -p ./test_output
          docker compose -f deployment/docker-compose.test.yml run --rm \
            -v $(pwd)/test_output:/code/test_output test_runner sh -c "
            pip install coverage unittest-xml-reporting --no-cache-dir &&
            export PYTHONDONTWRITEBYTECODE=1 &&
            export PYTHONUNBUFFERED=1 &&
            export TEST_OUTPUT_DIR=/code/test_output/test-results-${{ matrix.test-group.name }} &&
            coverage run --source='.' manage.py test ${{ matrix.test-group.apps }} \
              --settings=config.settings_test \
              --no-input \
              --verbosity=2 &&
            coverage report &&
            coverage xml -o /code/test_output/coverage-${{ matrix.test-group.name }}.xml
          "

      - name: Upload coverage artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.2
        with:
          name: coverage-${{ matrix.test-group.name }}
          path: ./test_output/coverage-${{ matrix.test-group.name }}.xml
          retention-days: 1

      - name: Upload test results artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.2
        with:
          name: test-results-${{ matrix.test-group.name }}
          path: ./test_output/test-results-${{ matrix.test-group.name }}/
          retention-days: 1

      - name: Cleanup
        if: always()
        run: docker compose -f deployment/docker-compose.test.yml down -v

  # Combine and upload coverage
  coverage-upload:
    runs-on: ubuntu-latest
    needs: test-suite
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0

      - name: Download coverage artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0  # v5.0.0
        with:
          pattern: coverage-*
          merge-multiple: true
          path: ./coverage-reports

      - name: Download test results artifacts
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0  # v5.0.0
        with:
          pattern: test-results-*
          merge-multiple: true
          path: ./test-results

      - name: Set up Python
        uses: actions/setup-python@bba65e51ff35d50c6dbaaacd8a4681db13aa7cb4  # v6.0.0
        with:
          python-version: '3.12.2'

      - name: Install coverage
        run: |
          pip install coverage

      - name: Merge coverage files
        run: |
          ls -la ./coverage-reports/
          if ls ./coverage-reports/coverage-*.xml 1> /dev/null 2>&1; then
            cp ./coverage-reports/coverage-*.xml .
            echo "Found coverage files:"
            ls -la coverage-*.xml
          else
            echo "No coverage files found, creating empty one"
            echo '<?xml version="1.0"?><coverage></coverage>' > coverage.xml
          fi

      - name: Upload to Codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7  # v5.5.1
        with:
          files: ./coverage-*.xml
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload test results to Codecov
        uses: codecov/test-results-action@v1  # v1.1.1
        with:
          files: ./test-results/**/*.xml
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}

  # Cleanup artifacts if tests fail
  cleanup-artifacts:
    runs-on: ubuntu-latest
    needs: [django-checks, test-suite]
    if: always() && (needs.django-checks.result == 'failure' || needs.test-suite.result == 'failure')
    steps:
      - name: Delete Docker image artifact
        uses: geekyeggo/delete-artifact@v5
        with:
          name: docker-image
          failOnError: false

      - name: Delete coverage artifacts
        uses: geekyeggo/delete-artifact@v5
        with:
          name: |
            coverage-*
            test-results-*
          failOnError: false

  # Final check to ensure all jobs passed (gate before pushing images)
  all-checks:
    runs-on: ubuntu-latest
    needs: [build-docker-image, django-checks, test-suite, pre-commit-checks, coverage-upload, build-production-images]
    if: always()
    steps:
      - name: Check if all jobs passed
        run: |
          BUILD_STATUS="${{ needs.build-docker-image.result }}"
          if [[ "$BUILD_STATUS" != "success" ]]; then
            echo "‚ùå Docker build failed (status: $BUILD_STATUS)"
            exit 1
          fi

          DJANGO_STATUS="${{ needs.django-checks.result }}"
          if [[ "$DJANGO_STATUS" != "success" ]]; then
            echo "‚ùå Django checks failed (status: $DJANGO_STATUS)"
            exit 1
          fi

          TEST_STATUS="${{ needs.test-suite.result }}"
          if [[ "$TEST_STATUS" != "success" ]]; then
            echo "‚ùå Test suite failed (status: $TEST_STATUS)"
            exit 1
          fi

          PRECOMMIT_STATUS="${{ needs.pre-commit-checks.result }}"
          if [[ "$PRECOMMIT_STATUS" != "success" ]]; then
            echo "‚ùå Pre-commit checks failed (status: $PRECOMMIT_STATUS)"
            exit 1
          fi

          COVERAGE_STATUS="${{ needs.coverage-upload.result }}"
          if [[ "$COVERAGE_STATUS" != "success" ]]; then
            echo "‚ùå Coverage upload failed (status: $COVERAGE_STATUS)"
            exit 1
          fi

          PROD_BUILD_STATUS="${{ needs.build-production-images.result }}"

          # Only fail if production build ran and failed (skip if it was skipped for PRs)
          if [[ "$PROD_BUILD_STATUS" != "success" && "$PROD_BUILD_STATUS" != "skipped" ]]; then
            echo "‚ùå Production image build failed (status: $PROD_BUILD_STATUS)"
            exit 1
          fi

          if [[ "$PROD_BUILD_STATUS" == "skipped" ]]; then
            echo "‚è≠Ô∏è  Production image build skipped (not on main branch)"
          else
            echo "‚úÖ Production images built in parallel with tests"
          fi

          echo "‚úÖ All checks passed successfully!"

  # Push production images from cache after all checks pass
  push-production-images:
    runs-on: ubuntu-latest
    needs: [all-checks]
    if: github.ref == 'refs/heads/main' && needs.all-checks.result == 'success'
    timeout-minutes: 15
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1
        with:
          driver-opts: |
            network=host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push production images from cache
        uses: docker/bake-action@a4d7f0b5b91c14a296d792d4ec53a9db17f02e67  # v5.10.0
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_PREFIX: ${{ github.repository }}
          TAG: ${{ github.sha }}
        with:
          files: deployment/docker-bake.hcl
          targets: production
          push: true
          set: |
            *.cache-from=type=gha,scope=prod-${{ github.sha }}
            *.cache-from=type=gha
          provenance: false
          sbom: false
