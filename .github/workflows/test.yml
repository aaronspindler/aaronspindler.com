name: Pipeline - Tests

run-name: "${{ github.event.head_commit.message || github.event.pull_request.title || 'Run Tests' }}"

on:
  push:
    branches: [ 'main' ]  # Only run on direct pushes to main
    paths-ignore:  # Skip workflow for documentation-only changes
      - '**.md'
      - 'docs/**'
      - '.cursor/**'
      - 'LICENSE'
      - '.gitignore'
  pull_request:
    branches: [ '**' ]  # Run on all PRs
    types: [ opened, synchronize, reopened, ready_for_review ]
    paths-ignore:  # Skip workflow for documentation-only changes
      - '**.md'
      - 'docs/**'
      - '.cursor/**'
      - 'LICENSE'
      - '.gitignore'
  workflow_dispatch:

# Cancel in-progress test runs for fast feedback
# Prevents resource contention by limiting concurrent workflow runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SECRET_KEY: "FAKE_SECRET_KEY"
  PYTHONUNBUFFERED: 1
  DOCKER_IMAGE_NAME: test-runner
  REGISTRY: ghcr.io
  TEST_COMPOSE_FILES: -f deployment/docker-compose.test.yml -f deployment/docker-compose.test.ci.yml
  # Phase 2 Optimization: Registry-based image distribution
  # Use unique tag per workflow run for parallel pulls across jobs
  TEST_IMAGE_TAG: test-${{ github.run_id }}
  # Cache versions - bump these to invalidate caches
  PIP_CACHE_VERSION: v1
  DOCKER_CACHE_VERSION: v2

permissions:
  contents: read
  packages: write  # Required for pushing test images to GHCR

jobs:
  # Phase 2 Optimization: Build and push test image to GHCR for fast parallel distribution
  # This eliminates 30-48 minutes of artifact download time across all test jobs
  # Registry pulls are much faster than artifact downloads and support layer caching
  build-docker-image:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      packages: write  # Required for pushing test images to GHCR
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:buildx-stable-1
          # Phase 3: Enable BuildKit features for cache mounts
          buildkitd-flags: --allow-insecure-entitlement security.insecure --allow-insecure-entitlement network.host

      - name: Verify Docker Compose file
        run: |
          if [ ! -f deployment/docker-compose.test.yml ]; then
            echo "‚ùå deployment/docker-compose.test.yml not found!"
            exit 1
          fi
          echo "‚úÖ deployment/docker-compose.test.yml found"

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Removed verbose diagnostic output - keeping build process streamlined

      - name: Build and push test image to GHCR
        id: bake
        uses: docker/bake-action@3acf805d94d93a86cce4ca44798a76464a75b88c  # v5.10.0
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_PREFIX: ${{ github.repository }}
          TAG: ${{ env.TEST_IMAGE_TAG }}  # Use the unique run ID tag
          # Phase 3: Enable BuildKit cache mounts for package managers
          DOCKER_BUILDKIT: 1
          BUILDKIT_INLINE_CACHE: 1
        with:
          files: deployment/docker-bake.hcl
          targets: test
          push: true
          set: |
            *.cache-from=type=gha,scope=buildx-${{ env.DOCKER_CACHE_VERSION }}
            *.cache-to=type=gha,mode=max,scope=buildx-${{ env.DOCKER_CACHE_VERSION }}


      - name: Verify test image was created
        run: |
          REGISTRY_TAG="${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TEST_IMAGE_TAG }}"
          docker pull "$REGISTRY_TAG"
          docker tag "$REGISTRY_TAG" "${{ env.DOCKER_IMAGE_NAME }}:latest"
          echo "‚úÖ Test image ready"

  # Build production images in parallel with tests (push with temp tag)
  build-production-images:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 15
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:buildx-stable-1
          buildkitd-flags: --allow-insecure-entitlement security.insecure --allow-insecure-entitlement network.host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push production images with temporary tag
        uses: docker/bake-action@3acf805d94d93a86cce4ca44798a76464a75b88c  # v5.10.0
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_PREFIX: ${{ github.repository }}
          TAG: build-${{ github.run_id }}
          DOCKER_BUILDKIT: 1
          BUILDKIT_INLINE_CACHE: 1
        with:
          files: deployment/docker-bake.hcl
          targets: production
          push: true
          set: |
            *.cache-from=type=gha,scope=buildx-${{ env.DOCKER_CACHE_VERSION }}
            *.cache-to=type=gha,mode=max,scope=buildx-${{ env.DOCKER_CACHE_VERSION }}
          provenance: false
          sbom: false

  django-checks:
    runs-on: ubuntu-latest
    needs: build-docker-image
    timeout-minutes: 10
    permissions:
      contents: read
      packages: read  # Required for pulling test images from GHCR
    strategy:
      matrix:
        check: [migrations, system]
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull test image from GHCR
        run: |
          docker pull ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TEST_IMAGE_TAG }}
          docker tag ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TEST_IMAGE_TAG }} ${{ env.DOCKER_IMAGE_NAME }}:latest
          echo "‚úÖ Image ready"

      - name: Start services
        run: |
          echo "Starting database services..."
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          docker compose $COMPOSE up -d postgres redis questdb

          # Wait for services to be healthy (optimized timeouts from Phase 1)
          echo "Waiting for services to be healthy..."
          timeout 30 sh -c 'until docker compose ${{ env.TEST_COMPOSE_FILES }} exec -T postgres pg_isready -U postgres; do sleep 1; done'
          timeout 30 sh -c 'until docker compose ${{ env.TEST_COMPOSE_FILES }} exec -T redis redis-cli ping; do sleep 1; done'
          # QuestDB health check - wait for container to be responsive
          timeout 30 sh -c 'until docker compose ${{ env.TEST_COMPOSE_FILES }} exec -T questdb echo "QuestDB is ready" 2>/dev/null; do sleep 1; done'

          echo "‚úÖ All services are healthy and ready"

      - name: Run Django ${{ matrix.check }} check
        run: |
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          case "${{ matrix.check }}" in
            migrations)
              docker compose $COMPOSE run --rm test_runner \
                python manage.py makemigrations --check --dry-run --settings=config.settings_test
              ;;
            system)
              docker compose $COMPOSE run --rm test_runner \
                python manage.py check --deploy --settings=config.settings_test
              ;;
          esac

      - name: Cleanup
        if: always()
        run: |
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          docker compose $COMPOSE down -v
          echo "‚úÖ Cleanup complete"

  test-suite:
    runs-on: ubuntu-latest
    needs: build-docker-image
    timeout-minutes: 30
    permissions:
      contents: read
      packages: read  # Required for pulling test images from GHCR
    strategy:
      fail-fast: false
      matrix:
        # Phase 3 Priority 4 & 5: Dynamic test splitting with balanced groups
        # Groups rebalanced based on actual timing data from previous runs
        # Smart test selection: Matrix can be conditionally modified based on changed files
        test-group:
          - name: "accounts-config"
            apps: "accounts config"
            estimated_time: 12
            paths: ["accounts/**", "config/**"]
          - name: "pages-utils"
            apps: "pages utils"
            estimated_time: 14
            paths: ["pages/**", "utils/**"]
          - name: "blog"
            apps: "blog"
            estimated_time: 15
            paths: ["blog/**"]
          - name: "photos"
            apps: "photos"
            estimated_time: 13
            paths: ["photos/**"]
          # - name: "feefifofunds"
          #   apps: "feefifofunds"
          #   estimated_time: 10
          #   paths: ["feefifofunds/**"]
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull test image from GHCR
        run: |
          docker pull ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TEST_IMAGE_TAG }}
          docker tag ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.TEST_IMAGE_TAG }} ${{ env.DOCKER_IMAGE_NAME }}:latest
          echo "‚úÖ Image ready"

      - name: Start services
        run: |
          echo "Starting database services..."
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          docker compose $COMPOSE up -d postgres redis questdb

          # Wait for services to be healthy (optimized timeouts from Phase 1)
          echo "Waiting for services to be healthy..."
          timeout 30 sh -c 'until docker compose ${{ env.TEST_COMPOSE_FILES }} exec -T postgres pg_isready -U postgres; do sleep 1; done'
          timeout 30 sh -c 'until docker compose ${{ env.TEST_COMPOSE_FILES }} exec -T redis redis-cli ping; do sleep 1; done'
          # QuestDB health check - wait for container to be responsive
          timeout 30 sh -c 'until docker compose ${{ env.TEST_COMPOSE_FILES }} exec -T questdb echo "QuestDB is ready" 2>/dev/null; do sleep 1; done'

          echo "‚úÖ All services are healthy and ready"
          echo "Estimated test time for this group: ${{ matrix.test-group.estimated_time }} minutes"

      - name: Run tests for ${{ matrix.test-group.name }}
        run: |
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          mkdir -p ./test_output

          docker compose $COMPOSE run --rm \
            -v $(pwd)/test_output:/code/test_output \
            -v $(pwd)/pyproject.toml:/code/pyproject.toml:ro \
            test_runner sh -c "
            pip install coverage unittest-xml-reporting pytest-json-report --root-user-action=ignore &&
            export PYTHONDONTWRITEBYTECODE=1 &&
            export PYTHONUNBUFFERED=1 &&
            export COVERAGE_RCFILE=/code/pyproject.toml &&
            export TEST_OUTPUT_DIR=/code/test_output/test-results-${{ matrix.test-group.name }} &&
            coverage run manage.py test ${{ matrix.test-group.apps }} \
              --settings=config.settings_test \
              --no-input \
              --verbosity=2 \
              --timing &&
            coverage report &&
            coverage xml -o /code/test_output/coverage-${{ matrix.test-group.name }}.xml
          "

          echo "‚úÖ Tests completed"

      - name: Upload coverage artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        with:
          name: coverage-${{ matrix.test-group.name }}
          path: ./test_output/coverage-${{ matrix.test-group.name }}.xml
          retention-days: 1

      - name: Upload test results artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        with:
          name: test-results-${{ matrix.test-group.name }}
          path: ./test_output/test-results-${{ matrix.test-group.name }}/
          retention-days: 1

      - name: Cleanup
        if: always()
        run: |
          COMPOSE="${{ env.TEST_COMPOSE_FILES }}"
          docker compose $COMPOSE down -v
          echo "‚úÖ Cleanup complete"

  # Coverage upload runs in parallel and doesn't block deployment
  # Coverage is informational - tests already passed, this just reports metrics
  coverage-upload:
    runs-on: ubuntu-latest
    needs: test-suite
    if: always()  # Run even if other jobs are running
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd  # v5.0.1

      - name: Download coverage artifacts
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          pattern: coverage-*
          merge-multiple: true
          path: ./coverage-reports

      - name: Download test results artifacts
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          pattern: test-results-*
          merge-multiple: true
          path: ./test-results

      - name: Set up Python
        uses: actions/setup-python@bfc4944b43a5d84377eca3cf6ab5b7992ba61923  # v6.0.0
        with:
          python-version: '3.12.2'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.local
          key: ${{ runner.os }}-pip-coverage-${{ env.PIP_CACHE_VERSION }}-${{ hashFiles('requirements/*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-coverage-${{ env.PIP_CACHE_VERSION }}-

      - name: Install coverage
        run: |
          pip install coverage

      - name: Merge coverage files
        run: |
          ls -la ./coverage-reports/
          if ls ./coverage-reports/coverage-*.xml 1> /dev/null 2>&1; then
            cp ./coverage-reports/coverage-*.xml .
            echo "Found coverage files:"
            ls -la coverage-*.xml
          else
            echo "No coverage files found, creating empty one"
            echo '<?xml version="1.0"?><coverage></coverage>' > coverage.xml
          fi

      - name: Upload to Codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7  # v5.5.1
        with:
          files: ./coverage-*.xml
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Upload test results to Codecov
        uses: codecov/test-results-action@v1  # v1.1.1
        with:
          files: ./test-results/**/*.xml
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}


  # Final check to ensure all jobs passed (gate before tagging images)
  # Coverage upload runs in parallel and doesn't block this check
  all-checks:
    runs-on: ubuntu-latest
    needs: [build-docker-image, django-checks, test-suite, build-production-images]
    if: always()
    steps:
      - name: Check if all jobs passed
        run: |
          BUILD_STATUS="${{ needs.build-docker-image.result }}"
          if [[ "$BUILD_STATUS" != "success" ]]; then
            echo "‚ùå Docker build failed (status: $BUILD_STATUS)"
            exit 1
          fi

          DJANGO_STATUS="${{ needs.django-checks.result }}"
          if [[ "$DJANGO_STATUS" != "success" ]]; then
            echo "‚ùå Django checks failed (status: $DJANGO_STATUS)"
            exit 1
          fi

          TEST_STATUS="${{ needs.test-suite.result }}"
          if [[ "$TEST_STATUS" != "success" ]]; then
            echo "‚ùå Test suite failed (status: $TEST_STATUS)"
            exit 1
          fi

          PROD_BUILD_STATUS="${{ needs.build-production-images.result }}"
          # Only fail if production build ran and failed (skip if it was skipped for PRs)
          if [[ "$PROD_BUILD_STATUS" != "success" && "$PROD_BUILD_STATUS" != "skipped" ]]; then
            echo "‚ùå Production image build failed (status: $PROD_BUILD_STATUS)"
            exit 1
          fi

          if [[ "$PROD_BUILD_STATUS" == "skipped" ]]; then
            echo "‚è≠Ô∏è  Production image build skipped (not on main branch)"
          else
            echo "‚úÖ Production images built in parallel with tests"
          fi

          echo "‚úÖ All checks passed successfully!"
          echo ""
          echo "üöÄ OPTIMIZATIONS ACTIVE:"
          echo "  Phase 1: pip cache + health checks + rebalancing (8-12 min savings)"
          echo "  Phase 2: GHCR registry distribution (30-48 min savings)"
          echo "  Phase 3: BuildKit cache + timing data (5-10 min savings)"
          echo ""
          echo "üìä CUMULATIVE SAVINGS:"
          echo "  TOTAL: 43-70 minutes saved (from ~45min baseline)"
          echo "  Target runtime: ~25-30 minutes (44% reduction)"

  # Re-tag production images with final SHA tag after all checks pass
  # Uses docker buildx imagetools for fast manifest copying (no rebuild or re-push)
  tag-production-images:
    runs-on: ubuntu-latest
    needs: [all-checks]
    if: github.ref == 'refs/heads/main' && needs.all-checks.result == 'success'
    timeout-minutes: 5
    permissions:
      contents: read
      packages: write
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Re-tag images with commit SHA (web)
        run: |
          docker buildx imagetools create \
            --tag ${{ env.REGISTRY }}/${{ github.repository }}-web:${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ github.repository }}-web:build-${{ github.run_id }}

      - name: Re-tag images with commit SHA (celery)
        run: |
          docker buildx imagetools create \
            --tag ${{ env.REGISTRY }}/${{ github.repository }}-celery:${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ github.repository }}-celery:build-${{ github.run_id }}

      - name: Re-tag images with commit SHA (celerybeat)
        run: |
          docker buildx imagetools create \
            --tag ${{ env.REGISTRY }}/${{ github.repository }}-celerybeat:${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ github.repository }}-celerybeat:build-${{ github.run_id }}

      - name: Re-tag images with commit SHA (flower)
        run: |
          docker buildx imagetools create \
            --tag ${{ env.REGISTRY }}/${{ github.repository }}-flower:${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ github.repository }}-flower:build-${{ github.run_id }}

  # Cleanup old test images from GHCR to avoid storage bloat
  # Keeps only the last 10 test images (sufficient for debugging recent runs)
  cleanup-test-images:
    runs-on: ubuntu-latest
    needs: [all-checks]
    if: always() && (github.ref == 'refs/heads/main' || github.event_name == 'pull_request')
    timeout-minutes: 5
    permissions:
      packages: write
    steps:
      - name: Delete old test images
        uses: actions/delete-package-versions@v5
        with:
          package-name: '${{ github.event.repository.name }}/test-runner'
          package-type: 'container'
          min-versions-to-keep: 10
          delete-only-untagged-versions: 'false'
        continue-on-error: true  # Don't fail workflow if cleanup fails
