name: Reusable Test and Check

on:
  workflow_call:
    inputs:
      python-version:
        description: 'Python version to use'
        required: false
        type: string
        default: '3.12.2'
      upload-coverage:
        description: 'Whether to upload coverage to Codecov'
        required: false
        type: boolean
        default: true
      ref:
        description: 'Git ref to checkout (branch, tag, or SHA)'
        required: false
        type: string
        default: ''

env:
  PYTHONUNBUFFERED: 1
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1
  DOCKER_IMAGE_NAME: test-runner

permissions:
  contents: read

jobs:
  # Build Docker image once and share it with other jobs
  build-docker-image:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ hashFiles('Dockerfile', 'requirements.txt', 'docker-compose.test.yml') }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      - name: Verify Docker Compose file
        run: |
          if [ ! -f docker-compose.test.yml ]; then
            echo "❌ docker-compose.test.yml not found!"
            exit 1
          fi
          echo "✅ docker-compose.test.yml found"
      
      - name: Build Docker image
        run: |
          docker compose -f docker-compose.test.yml build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            test_runner
          
          # Docker Compose v2 creates images with pattern: <project>-<service>
          # The project name is derived from the directory name
          PROJECT_NAME=$(basename $(pwd) | tr '[:upper:]' '[:lower:]' | tr '.' '-')
          IMAGE_NAME="${PROJECT_NAME}-test_runner"
          echo "Looking for image: $IMAGE_NAME"
          
          # List images for debugging
          echo "Available images after build:"
          docker images | grep -E "(REPOSITORY|${PROJECT_NAME})"
          
          # Tag the image for easier reference
          if docker image inspect "${IMAGE_NAME}:latest" >/dev/null 2>&1; then
            echo "Tagging ${IMAGE_NAME}:latest as ${{ env.DOCKER_IMAGE_NAME }}:latest"
            docker tag "${IMAGE_NAME}:latest" "${{ env.DOCKER_IMAGE_NAME }}:latest"
          elif docker image inspect "${IMAGE_NAME}" >/dev/null 2>&1; then
            echo "Tagging ${IMAGE_NAME} as ${{ env.DOCKER_IMAGE_NAME }}:latest"
            docker tag "${IMAGE_NAME}" "${{ env.DOCKER_IMAGE_NAME }}:latest"
          else
            echo "Error: Could not find built image ${IMAGE_NAME}"
            echo "All available images:"
            docker images
            exit 1
          fi
      
      - name: Save Docker image to file
        run: |
          docker save ${{ env.DOCKER_IMAGE_NAME }}:latest | gzip > test-runner-image.tar.gz
          echo "Image size: $(du -h test-runner-image.tar.gz | cut -f1)"
      
      - name: Upload Docker image as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: test-runner-image.tar.gz
          retention-days: 1
          compression-level: 0  # Already compressed

  # Quick security check (no Docker needed)
  security-check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ inputs.python-version }}
          cache: 'pip'
          cache-dependency-path: requirements.txt
      
      - name: Install and run safety
        env:
          SAFETY_API_KEY: ${{ secrets.SAFETY_API_KEY }}
        run: |
          python -m pip install --upgrade pip
          pip install safety
          safety --disable-telemetry scan --json || true
        continue-on-error: false

  # Django checks (parallel matrix)
  django-checks:
    runs-on: ubuntu-latest
    needs: build-docker-image
    timeout-minutes: 10
    strategy:
      matrix:
        check: [migrations, system]
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      
      - name: Load Docker image
        run: |
          echo "Loading Docker image..."
          docker load < /tmp/test-runner-image.tar.gz
          docker images | grep test-runner
          
          # Update docker-compose.test.yml to use the loaded image
          sed -i 's|build: \.|image: test-runner:latest|g' docker-compose.test.yml
      
      - name: Start required services
        run: |
          docker compose -f docker-compose.test.yml up -d postgres redis
          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          timeout 60s bash -c 'until docker compose -f docker-compose.test.yml ps --format json | grep -q "\"Health\":\"healthy\""; do echo "Waiting for services..."; sleep 2; done' || echo "Warning: Services health check timed out"
      
      - name: Run Django ${{ matrix.check }} check
        run: |
          case "${{ matrix.check }}" in
            migrations)
              docker compose -f docker-compose.test.yml run --rm test_runner \
                python manage.py makemigrations --check --dry-run --settings=config.settings_test
              ;;
            system)
              docker compose -f docker-compose.test.yml run --rm test_runner \
                python manage.py check --deploy --settings=config.settings_test
              ;;
          esac
      
      - name: Cleanup
        if: always()
        run: docker compose -f docker-compose.test.yml down -v

  # Test suite split into groups (parallel matrix)
  test-suite:
    runs-on: ubuntu-latest
    needs: build-docker-image
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        test-group:
          - name: "core"
            apps: "accounts pages config"
          - name: "content"
            apps: "blog photos"
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      
      - name: Load Docker image
        run: |
          echo "Loading Docker image..."
          docker load < /tmp/test-runner-image.tar.gz
          docker images | grep test-runner
          
          # Update docker-compose.test.yml to use the loaded image
          sed -i 's|build: \.|image: test-runner:latest|g' docker-compose.test.yml
      
      - name: Start test services
        run: |
          docker compose -f docker-compose.test.yml up -d postgres redis localstack
          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          timeout 60s bash -c 'until docker compose -f docker-compose.test.yml ps --format json | grep -q "\"Health\":\"healthy\""; do echo "Waiting for services..."; sleep 2; done' || echo "Warning: Services health check timed out"
      
      - name: Run tests for ${{ matrix.test-group.name }}
        run: |
          mkdir -p ./test_output
          docker compose -f docker-compose.test.yml run --rm \
            -v $(pwd)/test_output:/code/test_output test_runner sh -c "
            pip install coverage --no-cache-dir &&
            coverage run --source='.' manage.py test ${{ matrix.test-group.apps }} --settings=config.settings_test --no-input --parallel --verbosity=2 &&
            coverage report &&
            coverage xml -o /code/test_output/coverage-${{ matrix.test-group.name }}.xml
          "
      
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.test-group.name }}
          path: ./test_output/coverage-${{ matrix.test-group.name }}.xml
          retention-days: 1
      
      - name: Cleanup
        if: always()
        run: docker compose -f docker-compose.test.yml down -v

  # Combine and upload coverage
  coverage-upload:
    runs-on: ubuntu-latest
    needs: test-suite
    if: inputs.upload-coverage
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          merge-multiple: true
          path: ./coverage-reports
      
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ inputs.python-version }}
      
      - name: Install coverage
        run: |
          pip install coverage
      
      - name: Merge coverage files
        run: |
          # List downloaded files for debugging
          ls -la ./coverage-reports/
          
          # Since we have XML files, we need to use a different approach
          # We'll just concatenate them for Codecov which handles multiple files
          if ls ./coverage-reports/coverage-*.xml 1> /dev/null 2>&1; then
            # Copy all coverage files to current directory for Codecov
            cp ./coverage-reports/coverage-*.xml .
            echo "Found coverage files:"
            ls -la coverage-*.xml
          else
            echo "No coverage files found, creating empty one"
            echo '<?xml version="1.0"?><coverage></coverage>' > coverage.xml
          fi
      
      - name: Upload to Codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7
        with:
          files: ./coverage-*.xml
          fail_ci_if_error: false
          verbose: true

  # Final check to ensure all jobs passed
  all-checks:
    runs-on: ubuntu-latest
    needs: [build-docker-image, security-check, django-checks, test-suite]
    if: always()
    steps:
      - name: Check if all jobs passed
        run: |
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "One or more checks failed"
            exit 1
          fi
          echo "All checks passed successfully!"
