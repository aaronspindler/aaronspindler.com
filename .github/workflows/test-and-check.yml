name: Reusable Test and Check

on:
  workflow_call:
    inputs:
      python-version:
        description: 'Python version to use'
        required: false
        type: string
        default: '3.12.2'
      upload-coverage:
        description: 'Whether to upload coverage to Codecov'
        required: false
        type: boolean
        default: true
      ref:
        description: 'Git ref to checkout (branch, tag, or SHA)'
        required: false
        type: string
        default: ''

env:
  PYTHONUNBUFFERED: 1
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

permissions:
  contents: read

jobs:
  # Quick security check (no Docker needed)
  security-check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ inputs.python-version }}
          cache: 'pip'
          cache-dependency-path: requirements.txt
      
      - name: Install and run safety
        run: |
          python -m pip install --upgrade pip
          pip install safety
          safety check --json || true
        continue-on-error: true

  # Django checks (parallel matrix)
  django-checks:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        check: [migrations, system]
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ hashFiles('Dockerfile', 'requirements.txt', 'docker-compose.test.yml') }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      - name: Verify Docker Compose file
        run: |
          if [ ! -f docker-compose.test.yml ]; then
            echo "❌ docker-compose.test.yml not found!"
            exit 1
          fi
          echo "✅ docker-compose.test.yml found"
      
      - name: Build Docker images
        run: |
          docker compose -f docker-compose.test.yml build \
            --build-arg BUILDKIT_INLINE_CACHE=1
      
      - name: Start required services
        run: |
          docker compose -f docker-compose.test.yml up -d postgres redis
          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          timeout 60s bash -c 'until docker compose -f docker-compose.test.yml ps --format json | grep -q "\"Health\":\"healthy\""; do echo "Waiting for services..."; sleep 2; done' || echo "Warning: Services health check timed out"
      
      - name: Run Django ${{ matrix.check }} check
        run: |
          case "${{ matrix.check }}" in
            migrations)
              docker compose -f docker-compose.test.yml run --rm test_runner \
                python manage.py makemigrations --check --dry-run --settings=config.settings_test
              ;;
            system)
              docker compose -f docker-compose.test.yml run --rm test_runner \
                python manage.py check --deploy --settings=config.settings_test
              ;;
          esac
      
      - name: Cleanup
        if: always()
        run: docker compose -f docker-compose.test.yml down -v

  # Test suite split into groups (parallel matrix)
  test-suite:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        test-group:
          - name: "core"
            apps: "accounts pages config"
          - name: "content"
            apps: "blog photos"
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ hashFiles('Dockerfile', 'requirements.txt', 'docker-compose.test.yml') }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      - name: Verify Docker Compose file
        run: |
          if [ ! -f docker-compose.test.yml ]; then
            echo "❌ docker-compose.test.yml not found!"
            exit 1
          fi
          echo "✅ docker-compose.test.yml found"
      
      - name: Build Docker images
        run: |
          docker compose -f docker-compose.test.yml build \
            --build-arg BUILDKIT_INLINE_CACHE=1
      
      - name: Start test services
        run: |
          docker compose -f docker-compose.test.yml up -d postgres redis localstack
          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          timeout 60s bash -c 'until docker compose -f docker-compose.test.yml ps --format json | grep -q "\"Health\":\"healthy\""; do echo "Waiting for services..."; sleep 2; done' || echo "Warning: Services health check timed out"
      
      - name: Run tests for ${{ matrix.test-group.name }}
        run: |
          mkdir -p ./test_output
          docker compose -f docker-compose.test.yml run --rm \
            -v $(pwd)/test_output:/code/test_output test_runner sh -c "
            pip install coverage --no-cache-dir &&
            coverage run --source='.' manage.py test ${{ matrix.test-group.apps }} --settings=config.settings_test --no-input --parallel --verbosity=2 &&
            coverage report &&
            coverage xml -o /code/test_output/coverage-${{ matrix.test-group.name }}.xml
          "
      
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.test-group.name }}
          path: ./test_output/coverage-${{ matrix.test-group.name }}.xml
          retention-days: 1
      
      - name: Cleanup
        if: always()
        run: docker compose -f docker-compose.test.yml down -v

  # Combine and upload coverage
  coverage-upload:
    runs-on: ubuntu-latest
    needs: test-suite
    if: inputs.upload-coverage
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          token: ${{ github.token }}
      
      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          merge-multiple: true
          path: ./coverage-reports
      
      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ inputs.python-version }}
      
      - name: Install coverage
        run: |
          pip install coverage
      
      - name: Merge coverage files
        run: |
          # List downloaded files for debugging
          ls -la ./coverage-reports/
          
          # Since we have XML files, we need to use a different approach
          # We'll just concatenate them for Codecov which handles multiple files
          if ls ./coverage-reports/coverage-*.xml 1> /dev/null 2>&1; then
            # Copy all coverage files to current directory for Codecov
            cp ./coverage-reports/coverage-*.xml .
            echo "Found coverage files:"
            ls -la coverage-*.xml
          else
            echo "No coverage files found, creating empty one"
            echo '<?xml version="1.0"?><coverage></coverage>' > coverage.xml
          fi
      
      - name: Upload to Codecov
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7
        with:
          files: ./coverage-*.xml
          fail_ci_if_error: false
          verbose: true

  # Final check to ensure all jobs passed
  all-checks:
    runs-on: ubuntu-latest
    needs: [security-check, django-checks, test-suite]
    if: always()
    steps:
      - name: Check if all jobs passed
        run: |
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "One or more checks failed"
            exit 1
          fi
          echo "All checks passed successfully!"
