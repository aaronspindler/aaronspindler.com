{% load static %}

<!-- Knowledge Graph CSS -->
<link rel="stylesheet" href="{% static 'css/knowledge_graph.css' %}">

<div class="knowledge-graph-section">
    <div id="knowledge-graph-container">
        <div id="loading">
            Loading knowledge graph...
        </div>
        <svg id="knowledge-graph-svg"></svg>
    </div>
</div>

<script>
class HomepageKnowledgeGraph {
    constructor() {
        // Configuration constants
        this.CONFIG = {
            // Dimensions
            DEFAULT_WIDTH: 800,
            DEFAULT_HEIGHT: 500,
            
            // Tooltip settings
            TOOLTIP_PADDING: 20,
            TOOLTIP_LINE_HEIGHT: 22,
            TOOLTIP_MAX_WIDTH: 380,
            TOOLTIP_BLOG_MAX_WIDTH: 480,
            TOOLTIP_MIN_WIDTH: 100,
            TOOLTIP_ARROW_SIZE: 10,
            TOOLTIP_OFFSET: 20,
            TOOLTIP_MARGIN: 20,
            TOOLTIP_ANIMATION_DURATION: 250,
            
            // Font sizes
            TITLE_FONT_SIZE: '16px',
            SUBTITLE_FONT_SIZE: '14px',
            
            // Node settings
            NODE_MIN_RADIUS: 6,
            NODE_MAX_RADIUS: 16,
            NODE_EXTERNAL_RADIUS: 8,
            NODE_BASE_RADIUS: 5,
            NODE_CONNECTION_MULTIPLIER: 1.5,
            
            // Text display settings
            LABEL_MAX_LENGTH: 26,
            LABEL_SHORT_LENGTH: 18,
            BLOG_ENTRY_PATTERN: /^(\d{4})/,
            
            // Animation settings
            RIPPLE_DURATION: 1000,
            RIPPLE_RADIUS: 50,
            CLICK_DELAY: 200,
            RESIZE_DEBOUNCE: 150
        };
        
        this.svg = d3.select("#knowledge-graph-svg");
        this.container = d3.select("#knowledge-graph-container");
        this.loading = d3.select("#loading");
        
        // Get container dimensions
        const containerRect = this.container.node().getBoundingClientRect();
        this.width = containerRect.width || this.CONFIG.DEFAULT_WIDTH;
        this.height = containerRect.height || this.CONFIG.DEFAULT_HEIGHT;
        
        // Colors - adjusted for dark mode visibility
        this.COLORS = {
            blogPost: '#888',
            externalLink: '#aaa',
            highlight: '#fff',
            white: '#fff',
            // Category colors for nodes and hulls - brighter for dark mode
            categoryColors: {
                'tech': { 
                    node: '#5fb4b6', 
                    hull: 'rgba(95, 180, 182, 0.2)', 
                    border: 'rgba(95, 180, 182, 0.7)',
                    text: '#7dd8da'
                },
                'personal': { 
                    node: '#c594c5', 
                    hull: 'rgba(197, 148, 197, 0.2)', 
                    border: 'rgba(197, 148, 197, 0.7)',
                    text: '#dbb3db'
                },
                'projects': { 
                    node: '#fac863', 
                    hull: 'rgba(250, 200, 99, 0.2)', 
                    border: 'rgba(250, 200, 99, 0.7)',
                    text: '#ffd885'
                },
                'default': { 
                    node: '#999', 
                    hull: 'rgba(153, 153, 153, 0.2)', 
                    border: 'rgba(153, 153, 153, 0.7)',
                    text: '#bbb'
                }
            }
        };
        
        // Force simulation configuration
        this.FORCE_CONFIG = {
            linkDistance: 90,  // Much more spacing between nodes
            chargeStrength: -200,  // Much stronger repulsion for better spacing
            collisionRadius: 25,  // Larger collision radius for more personal space
            centerStrength: 0.02,  // Even weaker center pull
            categoryStrength: 0.25,  // Looser category clustering for more spread
            basePadding: 60,  // More padding for category hulls
            paddingPerNode: 12,  // More padding per node
            labelRepulsionStrength: 40,  // Strong repulsion force for labels
            labelRepulsionRadius: 140  // Larger detection radius around category labels
        };
        
        // Store category label positions for collision detection
        this.categoryLabelBounds = [];
        
        this.setupSVG();
        this.loadData();
        
        // Handle window resize with debouncing
        this.resizeTimeout = null;
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => this.handleResize(), this.CONFIG.RESIZE_DEBOUNCE);
        });
        
        // Add keyboard shortcuts
        window.addEventListener('keydown', (event) => {
            // Press 'f' to fit graph to view
            if (event.key === 'f' && !event.ctrlKey && !event.metaKey && !event.altKey) {
                this.fitGraphToView();
            }
            // Press 'r' to reset zoom
            if (event.key === 'r' && !event.ctrlKey && !event.metaKey && !event.altKey) {
                this.resetZoom();
            }
        });
    }
    
    setupSVG() {
        this.svg.attr("viewBox", [0, 0, this.width, this.height])
            .attr("width", this.width)
            .attr("height", this.height);
        
        // Create zoom behavior
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                this.g.attr("transform", event.transform);
            });
        
        this.svg.call(this.zoom);
        
        // Create main group for all graph elements
        this.g = this.svg.append("g");
        
        // Start zoomed out (20% scale) for more dramatic zoom-in effect
        const initialScale = 0.2;
        const initialTransform = d3.zoomIdentity
            .translate(this.width / 2 * (1 - initialScale), this.height / 2 * (1 - initialScale))
            .scale(initialScale);
        this.svg.call(this.zoom.transform, initialTransform);
        
        // Create tooltip group
        this.tooltipGroup = this.svg.append("g")
            .attr("class", "svg-tooltip");
        
        // Add controls info text
        this.svg.append("text")
            .attr("x", 10)
            .attr("y", this.height - 10)
            .attr("class", "controls-info")
            .style("font-size", "12px")
            .style("fill", "#666")
            .style("opacity", 0.7)
            .text("Press 'F' to fit graph • 'R' to reset zoom • Scroll to zoom • Drag to pan");
    }
    
    async loadData(forceRefresh = false) {
        try {
            this.loading.style("display", "block");
            
            // Add timestamp to prevent caching
            const timestamp = Date.now();
            const url = forceRefresh ?
                `/api/knowledge-graph/?refresh=true&t=${timestamp}` :
                `/api/knowledge-graph/?t=${timestamp}`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (result.status === 'success') {
                this.renderGraph(result.data);
            } else {
                console.error('API error:', result.error);
            }
        } catch (error) {
            console.error('Failed to load graph data:', error);
        } finally {
            this.loading.style("display", "none");
        }
    }
    
    renderGraph(data) {
        // Clear existing elements
        this.g.selectAll("*").remove();
        
        const { nodes, edges, categories } = data;
        
        if (!nodes || nodes.length === 0) {
            return;
        }
        
        // Store data for later use
        this.graphData = data;
        this.categories = categories || {};
        
        // Initialize node positions by category
        this.initializeNodePositionsByCategory(nodes);
        
        // Create force simulation with category clustering
        this.createForceSimulation(nodes, edges);
        
        // Create hull group first (background)
        this.hullGroup = this.g.append("g").attr("class", "hulls");
        
        // Create visual elements
        this.createLinks(edges);
        this.createNodes(nodes);
        this.createLabels(nodes);
        
        // Create a separate group for category labels (above everything)
        this.categoryLabelGroup = this.g.append("g").attr("class", "category-labels");
        
        // Add event handlers
        this.addEventHandlers();
        
        // Start simulation with very gradual settings for natural animation
        this.simulation
            .alpha(1.0)  // Start with full alpha
            .alphaDecay(0.01)  // Even slower decay for more settling time with increased spacing
            .velocityDecay(0.5)  // Start with high dampening (will be dynamically reduced)
            .alphaTarget(0)  // Target zero alpha
            .restart();
        
        // Delay initial category hull rendering until nodes are positioned
        setTimeout(() => {
            this.updateCategoryHulls();
        }, 100);
    }
    
    initializeNodePositionsByCategory(nodes) {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const categoryGroups = {};
        const externalLinks = [];
        
        // Group nodes by category and separate external links
        nodes.forEach(node => {
            if (node.type === 'external_link') {
                externalLinks.push(node);
            } else {
                const category = node.category || 'uncategorized';
                if (!categoryGroups[category]) {
                    categoryGroups[category] = [];
                }
                categoryGroups[category].push(node);
            }
        });
        
        // Store category centers for later use
        this.categoryCenters = {};
        
        // Position each category group with much more spacing
        const categories = Object.keys(categoryGroups);
        const angleStep = (2 * Math.PI) / Math.max(categories.length, 1);
        const groupRadius = Math.min(this.width, this.height) * 0.28;  // Much more spread out initially
        
        categories.forEach((category, catIndex) => {
            const categoryAngle = catIndex * angleStep;
            const groupCenterX = centerX + groupRadius * Math.cos(categoryAngle);
            const groupCenterY = centerY + groupRadius * Math.sin(categoryAngle);
            
            // Store category center
            this.categoryCenters[category] = { x: groupCenterX, y: groupCenterY };
            
            // Position nodes in a tight circular pattern within the category
            const nodesInCategory = categoryGroups[category];
            const nodeCount = nodesInCategory.length;
            
            if (nodeCount === 1) {
                // Single node at center
                nodesInCategory[0].x = groupCenterX;
                nodesInCategory[0].y = groupCenterY;
            } else {
                // Multiple nodes in concentric circles with more spacing
                const maxRadius = 80; // Fixed larger radius for consistent spacing
                let placedNodes = 0;
                let currentRadius = 0;
                let ring = 0;
                
                while (placedNodes < nodeCount) {
                    const nodesInRing = ring === 0 ? 1 : Math.min(6 * ring, nodeCount - placedNodes);
                    currentRadius = ring === 0 ? 0 : (maxRadius * ring) / Math.ceil(Math.sqrt(nodeCount));
                    
                    for (let i = 0; i < nodesInRing && placedNodes < nodeCount; i++) {
                        const angle = (i / nodesInRing) * 2 * Math.PI;
                        const node = nodesInCategory[placedNodes];
                        node.x = groupCenterX + currentRadius * Math.cos(angle);
                        node.y = groupCenterY + currentRadius * Math.sin(angle);
                        placedNodes++;
                    }
                    ring++;
                }
            }
        });
        
        // Position external links far from category areas
        if (externalLinks.length > 0) {
            const outerRadius = Math.min(this.width, this.height) * 0.42;  // Position at edges
            const externalAngleStep = (2 * Math.PI) / externalLinks.length;
            
            externalLinks.forEach((node, index) => {
                const angle = index * externalAngleStep + Math.random() * 0.1;  // Less randomness
                const radiusVariation = 0.95 + Math.random() * 0.1;  // Keep them far out
                node.x = centerX + outerRadius * radiusVariation * Math.cos(angle);
                node.y = centerY + outerRadius * radiusVariation * Math.sin(angle);
            });
        }
    }
    
    createForceSimulation(nodes, edges) {
        // Use stored category centers
        const categoryCenters = this.categoryCenters || this.calculateCategoryCenters();
        
        // Create links force but start disabled
        const linkForce = d3.forceLink(edges).id(d => d.id)
            .distance(d => {
                // External links get much more distance
                if (d.source.type === 'external_link' || d.target.type === 'external_link') {
                    return this.FORCE_CONFIG.linkDistance * 1.8;
                }
                // Shorter links within same category
                if (d.source.category && d.target.category && 
                    d.source.category === d.target.category) {
                    return this.FORCE_CONFIG.linkDistance * 0.8;
                }
                return this.FORCE_CONFIG.linkDistance;
            })
            .strength(0);  // Start with no link force
        
        // Create charge force but start very weak
        const chargeForce = d3.forceManyBody()
            .strength(d => {
                // Start with very weak repulsion
                const baseStrength = d.type === 'external_link' 
                    ? this.FORCE_CONFIG.chargeStrength * 2.0  // Stronger repulsion for external links
                    : d.category 
                        ? this.FORCE_CONFIG.chargeStrength * 0.5 
                        : this.FORCE_CONFIG.chargeStrength;
                return baseStrength * 0.1;  // Start at 10% strength
            });
        
        // Create collision force but start gentle
        const collisionForce = d3.forceCollide()
            .radius(d => {
                const baseRadius = d.type === 'external_link'
                    ? this.FORCE_CONFIG.collisionRadius * 1.8
                    : this.FORCE_CONFIG.collisionRadius;
                return baseRadius * 0.5;  // Start with smaller radius
            })
            .strength(0.3);  // Start gentle
        
        this.simulation = d3.forceSimulation(nodes)
            .force("link", linkForce)
            .force("charge", chargeForce)
            .force("collision", collisionForce)
            // Start with very weak category clustering
            .force("categoryX", d3.forceX(d => {
                if (d.type === 'external_link') {
                    // Push external links to the edges
                    const centerX = this.width / 2;
                    const angle = Math.atan2(d.y - this.height / 2, d.x - centerX);
                    const radius = Math.min(this.width, this.height) * 0.42;
                    return centerX + radius * Math.cos(angle);
                }
                const category = d.category || 'uncategorized';
                return categoryCenters[category]?.x || this.width / 2;
            }).strength(0.005))  // Extremely weak initially
            .force("categoryY", d3.forceY(d => {
                if (d.type === 'external_link') {
                    // Push external links to the edges
                    const centerY = this.height / 2;
                    const angle = Math.atan2(d.y - centerY, d.x - this.width / 2);
                    const radius = Math.min(this.width, this.height) * 0.42;
                    return centerY + radius * Math.sin(angle);
                }
                const category = d.category || 'uncategorized';
                return categoryCenters[category]?.y || this.height / 2;
            }).strength(0.005))  // Extremely weak initially
            // Add custom force to repel external nodes from category labels
            .force("labelRepulsion", this.createLabelRepulsionForce())
            // Add custom force to keep external links outside category areas
            .force("externalRepulsion", this.createExternalRepulsionForce())
            // Add custom force to prevent nodes from entering other categories
            .force("categoryBoundary", this.createCategoryBoundaryForce());
        
        // Store force references for gradual strengthening
        this.forces = {
            link: linkForce,
            charge: chargeForce,
            collision: collisionForce,
            targetLinkStrength: {
                external: 0.5,
                sameCat: 1.5,
                normal: 1.0
            }
        };
        
        // Update positions on simulation tick with throttled hull updates
        this.tickCount = 0;
        this.hasAutoFitted = false;  // Track if we've done the auto-fit
        this.simulation.on("tick", () => {
            const alpha = this.simulation.alpha();
            
            // Gradually strengthen forces as simulation progresses
            this.updateForceStrengths(alpha);
            
            this.updatePositions();
            // Update hulls every 3 ticks for smoother performance
            this.tickCount++;
            if (this.tickCount % 3 === 0) {
                this.updateCategoryHulls();
            }
            
            // Auto-fit the graph earlier while nodes are still settling for a more dynamic effect
            if (!this.hasAutoFitted && alpha < 0.4) {
                this.hasAutoFitted = true;
                setTimeout(() => this.fitGraphToView(), 500);  // Start zooming in while graph is forming
            }
        });
    }
    
    updateForceStrengths(alpha) {
        if (!this.forces) return;
        
        // Create smooth easing curve for force strength
        // Use custom easing for very gradual, natural animation
        const progress = 1 - alpha;  // 0 to 1 as simulation progresses
        
        // Multi-stage easing for different phases of animation
        let easeProgress;
        if (progress < 0.3) {
            // Very slow start (first 30%)
            easeProgress = progress * progress * 0.5;
        } else if (progress < 0.7) {
            // Gradual acceleration (30-70%)
            const p = (progress - 0.3) / 0.4;
            easeProgress = 0.045 + p * 0.455;
        } else {
            // Smooth finish (70-100%)
            const p = (progress - 0.7) / 0.3;
            easeProgress = 0.5 + Math.sqrt(p) * 0.5;
        }
        
        // Update link force strength
        this.forces.link.strength(d => {
            if (d.source.type === 'external_link' || d.target.type === 'external_link') {
                return this.forces.targetLinkStrength.external * easeProgress * 0.8;
            }
            if (d.source.category && d.target.category && 
                d.source.category === d.target.category) {
                return this.forces.targetLinkStrength.sameCat * easeProgress;
            }
            return this.forces.targetLinkStrength.normal * easeProgress;
        });
        
        // Update charge force strength
        this.forces.charge.strength(d => {
            const baseStrength = d.type === 'external_link' 
                ? this.FORCE_CONFIG.chargeStrength * 2.0  // Stronger repulsion for external links
                : d.category 
                    ? this.FORCE_CONFIG.chargeStrength * 0.5 
                    : this.FORCE_CONFIG.chargeStrength;
            
            // Slower ramp-up for charge to prevent initial chaos
            const chargeProgress = Math.min(1, easeProgress * 1.2);
            return baseStrength * chargeProgress * 0.8;  // Never go to full strength for smoother animation
        });
        
        // Update collision force
        this.forces.collision
            .radius(d => {
                const baseRadius = d.type === 'external_link'
                    ? this.FORCE_CONFIG.collisionRadius * 1.8
                    : this.FORCE_CONFIG.collisionRadius;
                // Gradually expand collision radius
                return baseRadius * (0.5 + 0.5 * easeProgress);
            })
            .strength(0.3 + 0.7 * easeProgress);  // Gradually strengthen collision
        
        // Update category clustering forces
        const categoryStrength = d => {
            if (d.type === 'external_link') {
                // Stronger force to keep external links on periphery
                return 0.01 + 0.15 * easeProgress;  // Stronger outward force
            }
            return 0.005 + (this.FORCE_CONFIG.categoryStrength - 0.005) * easeProgress * 0.8;
        };
        
        this.simulation.force("categoryX").strength(categoryStrength);
        this.simulation.force("categoryY").strength(categoryStrength);
        
        // Dynamic velocity decay for smoother motion
        // Start with high dampening and gradually reduce it
        const velocityDecay = 0.5 - (0.2 * easeProgress);  // From 0.5 to 0.3
        this.simulation.velocityDecay(velocityDecay);
    }
    
    createCategoryBoundaryForce() {
        return (alpha) => {
            const nodes = this.simulation ? this.simulation.nodes() : [];
            const categoryCenters = this.calculateCategoryCenters();
            
            // Skip if we're in early stages of simulation
            if (alpha > 0.5) return;
            
            // Progressive strength based on simulation progress
            const strengthMultiplier = alpha > 0.3 ? 
                0.3 * (1 - (alpha - 0.3) / 0.2) :  // Ramp up from 0.5 to 0.3
                0.3 + 0.7 * (0.3 - alpha) / 0.3;   // Full strength below 0.3
            
            nodes.forEach(node => {
                // Skip external links - they have their own repulsion
                if (node.type === 'external_link') return;
                
                const nodeCategory = node.category || 'uncategorized';
                
                // Check distance to all other category centers
                Object.entries(categoryCenters).forEach(([category, center]) => {
                    // Skip the node's own category
                    if (category === nodeCategory) return;
                    
                    const dx = node.x - center.x;
                    const dy = node.y - center.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Define boundary radius for each category (adjust based on number of nodes)
                    const categoryNodeCount = (this.categories[category] || []).length;
                    const boundaryRadius = 80 + categoryNodeCount * 15;  // Base radius + scaling
                    
                    // Apply repulsion if node is within boundary of another category
                    if (distance < boundaryRadius) {
                        const force = strengthMultiplier * 40 * alpha;
                        const repulsionStrength = force * Math.pow((boundaryRadius - distance) / boundaryRadius, 2);
                        
                        // Handle zero distance
                        if (distance === 0) {
                            const angle = Math.random() * 2 * Math.PI;
                            node.vx += Math.cos(angle) * repulsionStrength;
                            node.vy += Math.sin(angle) * repulsionStrength;
                        } else {
                            // Push node away from other category center
                            node.vx += (dx / distance) * repulsionStrength;
                            node.vy += (dy / distance) * repulsionStrength;
                        }
                    }
                });
            });
        };
    }
    
    createExternalRepulsionForce() {
        return (alpha) => {
            const nodes = this.simulation ? this.simulation.nodes() : [];
            const categoryCenters = this.categoryCenters || this.calculateCategoryCenters();
            
            // Apply strong repulsion to external links from category centers
            nodes.forEach(node => {
                if (node.type === 'external_link') {
                    // Check distance to each category center
                    Object.values(categoryCenters).forEach(center => {
                        const dx = node.x - center.x;
                        const dy = node.y - center.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Define minimum distance external links should stay from category centers
                        const minDistance = 200; // Larger minimum distance from category centers
                        
                        if (distance < minDistance && distance > 0) {
                            // Calculate repulsion force - stronger when closer
                            const force = Math.pow((minDistance - distance) / minDistance, 2);
                            const repulsionStrength = 80 * force * alpha;  // Stronger repulsion
                            
                            // Apply force to push node away
                            const forceX = (dx / distance) * repulsionStrength;
                            const forceY = (dy / distance) * repulsionStrength;
                            
                            node.vx = (node.vx || 0) + forceX;
                            node.vy = (node.vy || 0) + forceY;
                        }
                    });
                    
                    // Also add radial force to push external links outward
                    const centerX = this.width / 2;
                    const centerY = this.height / 2;
                    const dx = node.x - centerX;
                    const dy = node.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Target minimum radius for external links
                    const targetRadius = Math.min(this.width, this.height) * 0.42;
                    
                    if (distance < targetRadius && distance > 0) {
                        // Push outward if too close to center
                        const force = (targetRadius - distance) / targetRadius;
                        const outwardStrength = 50 * force * alpha;  // Stronger outward push
                        
                        const forceX = (dx / distance) * outwardStrength;
                        const forceY = (dy / distance) * outwardStrength;
                        
                        node.vx = (node.vx || 0) + forceX;
                        node.vy = (node.vy || 0) + forceY;
                    }
                }
            });
        };
    }
    
    createLabelRepulsionForce() {
        return (alpha) => {
            const nodes = this.simulation ? this.simulation.nodes() : [];
            
            // Create a smooth ramp-up of repulsion force
            // Start moderate and increase as simulation settles
            let strengthMultiplier;
            
            if (alpha > 0.7) {
                // Moderate repulsion at the beginning to keep nodes away from labels
                strengthMultiplier = 0.3;
            } else if (alpha > 0.3) {
                // Gradual increase in middle phase
                strengthMultiplier = 0.3 + 0.4 * (0.7 - alpha) / 0.4;
            } else {
                // Full strength when mostly settled
                strengthMultiplier = 0.7 + 0.3 * (0.3 - alpha) / 0.3;
            }
            
            // Apply repulsion to all nodes, but stronger for external links
            nodes.forEach(node => {
                // Check against each category label bound
                this.categoryLabelBounds.forEach(labelBound => {
                    const dx = node.x - labelBound.x;
                    const dy = node.y - labelBound.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Determine effective repulsion radius based on node type
                    const effectiveRadius = node.type === 'external_link' 
                        ? this.FORCE_CONFIG.labelRepulsionRadius 
                        : this.FORCE_CONFIG.labelRepulsionRadius * 0.5;
                    
                    // If node is within repulsion radius of label
                    if (distance < effectiveRadius && distance > 0) {
                        // Calculate repulsion force with smooth falloff
                        const normalizedDistance = distance / effectiveRadius;
                        const force = Math.max(0, 1 - normalizedDistance); // Linear falloff
                        
                        // Calculate strength with smooth multiplier
                        const baseStrength = node.type === 'external_link' 
                            ? this.FORCE_CONFIG.labelRepulsionStrength * 1.5
                            : this.FORCE_CONFIG.labelRepulsionStrength * 0.5;
                        
                        const repulsionStrength = baseStrength * force * strengthMultiplier;
                        
                        // Apply force to push node away smoothly
                        const forceX = (dx / distance) * repulsionStrength;
                        const forceY = (dy / distance) * repulsionStrength;
                        
                        // Apply force without hard clamping for smoother motion
                        node.vx = (node.vx || 0) + forceX;
                        node.vy = (node.vy || 0) + forceY;
                    } else if (distance === 0) {
                        // If exactly on top, push gently in a random direction
                        const angle = Math.random() * 2 * Math.PI;
                        const repulsionStrength = this.FORCE_CONFIG.labelRepulsionStrength * strengthMultiplier * 0.3;
                        
                        node.vx = (node.vx || 0) + Math.cos(angle) * repulsionStrength;
                        node.vy = (node.vy || 0) + Math.sin(angle) * repulsionStrength;
                    }
                });
            });
        };
    }
    
    resetZoom() {
        // Reset to identity transform (no zoom, no pan)
        this.svg.transition()
            .duration(750)
            .ease(d3.easeCubicInOut)
            .call(this.zoom.transform, d3.zoomIdentity);
    }
    
    fitGraphToView() {
        // Get all node positions to calculate bounds
        const nodes = this.simulation ? this.simulation.nodes() : [];
        if (nodes.length === 0) return;
        
        // Calculate the bounds of all nodes
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                const radius = this.getNodeRadius(node) || 10;
                minX = Math.min(minX, node.x - radius);
                maxX = Math.max(maxX, node.x + radius);
                minY = Math.min(minY, node.y - radius);
                maxY = Math.max(maxY, node.y + radius);
            }
        });
        
        // Add padding around the bounds
        const padding = 100;
        minX -= padding;
        maxX += padding;
        minY -= padding;
        maxY += padding;
        
        // Calculate the center and size of the bounding box
        const width = maxX - minX;
        const height = maxY - minY;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        
        // Calculate the scale to fit the graph in the viewport
        const scaleX = this.width / width;
        const scaleY = this.height / height;
        const scale = Math.min(scaleX, scaleY, 1.0);  // Don't zoom in more than 1.0x (100%)
        
        // Ensure we don't zoom out too much either
        const finalScale = Math.max(scale, 0.25);  // Minimum 25% zoom (slightly more than initial 20%)
        
        // Calculate the translation to center the graph
        const translateX = this.width / 2 - finalScale * centerX;
        const translateY = this.height / 2 - finalScale * centerY;
        
        // Create the transform
        const transform = d3.zoomIdentity
            .translate(translateX, translateY)
            .scale(finalScale);
        
        // Apply the zoom with a smooth, cinematic transition
        this.svg.transition()
            .duration(2500)  // 2.5 second transition for cinematic zoom-in effect
            .ease(d3.easeQuadInOut)  // Slightly different easing for smoother acceleration
            .call(this.zoom.transform, transform);
    }
    
    calculateCategoryCenters() {
        const centers = {};
        const categories = Object.keys(this.categories || {});
        const angleStep = (2 * Math.PI) / Math.max(categories.length, 1);
        const radius = Math.min(this.width, this.height) * 0.35;  // Much larger target position for more spacing
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        categories.forEach((category, index) => {
            const angle = index * angleStep;
            centers[category] = {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            };
        });
        
        // Add center for uncategorized nodes
        centers['uncategorized'] = { x: centerX, y: centerY };
        
        return centers;
    }
    
    createLinks(edges) {
        this.link = this.g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(edges)
            .enter().append("line")
            .attr("class", d => `link ${d.type}`)
            .attr("stroke", d => d.type === 'internal' ? this.COLORS.blogPost : this.COLORS.externalLink)
            .attr("stroke-opacity", 0.6)
            .attr("stroke-width", d => d.type === 'internal' ? 2 : 1);
    }
    
    createNodes(nodes) {
        this.node = this.g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", d => {
                if (d.type === 'blog_post') return `node blog-post ${d.category || 'uncategorized'}`;
                return `node ${d.type}`;
            })
            .attr("r", d => this.getNodeRadius(d))
            .attr("fill", d => {
                if (d.type === 'blog_post') {
                    const category = d.category || 'default';
                    const categoryColor = this.COLORS.categoryColors[category] || this.COLORS.categoryColors.default;
                    return categoryColor.node;
                }
                return this.COLORS.externalLink;
            })
            .attr("stroke", this.COLORS.white)
            .attr("stroke-width", 1.5)
            .call(this.createDragBehavior());
    }
    
    createLabels(nodes) {
        this.labels = this.g.append("g")
            .attr("class", "node-labels-group")
            .selectAll("text")
            .data(nodes)
            .enter().append("text")
            .attr("class", d => {
                if (d.type === 'blog_post') {
                    return "node-label blog-post-number";
                } else if (d.type === 'external_link') {
                    return "node-label external-link";
                }
                return "node-label";
            })
            .attr("fill", "currentColor")
            .style("fill", "var(--text-color)")
            .style("stroke", "var(--background-color)")
            .style("stroke-width", d => d.type === 'blog_post' ? "4px" : "3px")
            .style("stroke-linejoin", "round")
            .style("paint-order", "stroke")
            .text(d => this.getNodeLabel(d))
            .style("display", "block");
    }
    
    addEventHandlers() {
        this.node
            .on("mouseover", (event, d) => {
                this.showTooltip(event, d);
                this.highlightConnections(d);
            })
            .on("mouseout", (event, d) => {
                this.hideTooltip();
                this.clearHighlights();
            })
            .on("click", (event, d) => {
                this.handleNodeClick(event, d);
            });
    }
    
    calculateLabelPosition(d, allNodes) {
        const radius = this.getNodeRadius(d);
        let x = d.x || 0;
        let y = d.y || 0;
        
        if (d.type === 'external_link') {
            // Try different positions for external links to avoid overlaps
            const positions = [
                { x: x + radius + 8, y: y },         // Right
                { x: x - radius - 8, y: y },         // Left
                { x: x, y: y + radius + 15 },        // Below
                { x: x, y: y - radius - 15 },        // Above
                { x: x + radius + 5, y: y + radius + 5 },  // Bottom-right
                { x: x - radius - 5, y: y + radius + 5 },  // Bottom-left
            ];
            
            // Find position with least overlap
            let bestPos = positions[0];
            let minOverlap = Infinity;
            
            for (const pos of positions) {
                let overlap = 0;
                // Check overlap with other nodes
                for (const other of allNodes) {
                    if (other === d) continue;
                    const dx = pos.x - (other.x || 0);
                    const dy = pos.y - (other.y || 0);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const otherRadius = this.getNodeRadius(other);
                    if (distance < otherRadius + 20) {
                        overlap += (otherRadius + 20 - distance);
                    }
                }
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    bestPos = pos;
                }
            }
            
            return bestPos;
        } else if (d.type === 'blog_post') {
            // Blog post labels stay centered in the node
            return { x: x, y: y + 4 };
        }
        
        // Default: below the node
        return { x: x, y: y + radius + 12 };
    }

    updatePositions() {
        this.link
            .attr("x1", d => d.source.x || 0)
            .attr("y1", d => d.source.y || 0)
            .attr("x2", d => d.target.x || 0)
            .attr("y2", d => d.target.y || 0);
        
        this.node
            .attr("cx", d => d.x || 0)
            .attr("cy", d => d.y || 0);
        
        const allNodes = this.simulation ? this.simulation.nodes() : [];
        
        this.labels
            .each((d, i, nodes) => {
                const pos = this.calculateLabelPosition(d, allNodes);
                d3.select(nodes[i])
                    .attr("x", pos.x)
                    .attr("y", pos.y);
            });
    }
    
    updateCategoryHulls() {
        if (!this.hullGroup) return;
        
        // Group nodes by category
        const categoryGroups = {};
        const nodes = this.simulation ? this.simulation.nodes() : [];
        
        nodes.forEach(node => {
            if (node.type === 'blog_post' && node.category) {
                // Only add nodes with valid positions
                if (node.x !== undefined && node.y !== undefined && 
                    !isNaN(node.x) && !isNaN(node.y) &&
                    (Math.abs(node.x) > 1 || Math.abs(node.y) > 1)) {  // Not at origin
                    if (!categoryGroups[node.category]) {
                        categoryGroups[node.category] = [];
                    }
                    categoryGroups[node.category].push([node.x, node.y]);
                }
            }
        });
        
        // Clear existing hulls and labels
        this.hullGroup.selectAll("*").remove();
        if (this.categoryLabelGroup) {
            this.categoryLabelGroup.selectAll("*").remove();
        }
        
        // Clear category label bounds for recalculation
        this.categoryLabelBounds = [];
        
        // Draw organic hulls for each category
        Object.entries(categoryGroups).forEach(([category, points]) => {
            // Skip if no points or all points are invalid
            if (points.length === 0) return;
            
            // Validate points - filter out any remaining invalid ones
            const validPoints = points.filter(([x, y]) => 
                x !== undefined && y !== undefined && 
                !isNaN(x) && !isNaN(y) &&
                (Math.abs(x) > 1 || Math.abs(y) > 1)
            );
            
            if (validPoints.length === 0) return;
            points = validPoints;  // Use only valid points
            
            const categoryData = this.categories[category] || {};
            const categoryColor = this.COLORS.categoryColors[category] || this.COLORS.categoryColors.default;
            
            // Calculate dynamic padding based on node count
            const dynamicPadding = this.FORCE_CONFIG.basePadding + 
                (points.length * this.FORCE_CONFIG.paddingPerNode);
            
            if (points.length === 1) {
                // Single node - draw a circle around it
                const [x, y] = points[0];
                
                // Validate position before drawing
                if (x === undefined || y === undefined || isNaN(x) || isNaN(y)) return;
                
                this.hullGroup.append("circle")
                    .attr("class", `category-hull hull-${category}`)
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", dynamicPadding)
                    .style("fill", categoryColor.hull)
                    .style("stroke", categoryColor.border)
                    .style("stroke-width", 2)
                    .style("opacity", 0.8);
                
                // Add label for single node at top
                if (this.categoryLabelGroup && x > 10 && y > 10) {  // Only if position is reasonable
                    const labelY = y - dynamicPadding - 35;  // Much more spacing from hull
                    this.categoryLabelGroup.append("text")
                        .attr("class", "category-label")
                        .attr("x", x)
                        .attr("y", labelY)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("font-weight", "700")
                        .style("fill", categoryColor.text || categoryColor.border)
                        .style("stroke", "#1a1a1a")
                        .style("stroke-width", "3px")
                        .style("paint-order", "stroke")
                        .style("pointer-events", "none")
                        .text(category.toUpperCase());
                    
                    // Store label bounds for repulsion with buffer
                    this.categoryLabelBounds.push({
                        x: x,
                        y: labelY,
                        width: category.length * 14,  // Wider estimated width
                        height: 30,  // Taller height for buffer
                        category: category
                    });
                }
                    
            } else if (points.length === 2) {
                // Two nodes - draw an ellipse/capsule shape
                const [x1, y1] = points[0];
                const [x2, y2] = points[1];
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                this.hullGroup.append("ellipse")
                    .attr("class", `category-hull hull-${category}`)
                    .attr("cx", midX)
                    .attr("cy", midY)
                    .attr("rx", distance / 2 + dynamicPadding)
                    .attr("ry", dynamicPadding)
                    .attr("transform", `rotate(${angle} ${midX} ${midY})`)
                    .style("fill", categoryColor.hull)
                    .style("stroke", categoryColor.border)
                    .style("stroke-width", 2)
                    .style("opacity", 0.8);
                
                // Add label for two nodes at top
                if (this.categoryLabelGroup && midX > 10 && midY > 10) {  // Only if position is reasonable
                    const topY = Math.min(y1, y2) - dynamicPadding - 35;  // Much more spacing from hull
                    this.categoryLabelGroup.append("text")
                        .attr("class", "category-label")
                        .attr("x", midX)
                        .attr("y", topY)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("font-weight", "700")
                        .style("fill", categoryColor.text || categoryColor.border)
                        .style("stroke", "#1a1a1a")
                        .style("stroke-width", "3px")
                        .style("paint-order", "stroke")
                        .style("pointer-events", "none")
                        .text(category.toUpperCase());
                    
                    // Store label bounds for repulsion with buffer
                    this.categoryLabelBounds.push({
                        x: midX,
                        y: topY,
                        width: category.length * 14,  // Wider estimated width
                        height: 30,  // Taller height for buffer
                        category: category
                    });
                }
                    
            } else {
                // Multiple nodes - create organic blob shape
                const hull = d3.polygonHull(points);
                if (!hull) return;
                
                // Expand hull with dynamic padding
                const expandedHull = this.expandHull(hull, dynamicPadding);
                if (!expandedHull) return;
                
                // Create smooth blob path using Catmull-Rom curve
                const pathData = this.createBlobPath(expandedHull);
                
                // Draw the organic shape
                this.hullGroup.append("path")
                    .attr("class", `category-hull hull-${category}`)
                    .attr("d", pathData)
                    .style("fill", categoryColor.hull)
                    .style("stroke", categoryColor.border)
                    .style("stroke-width", 2)
                    .style("stroke-linejoin", "round")
                    .style("opacity", 0.8);
            }
            
            // Add category label at the top of the group
            const centroid = points.length > 0 ? d3.polygonCentroid(points) : null;
            if (!centroid || centroid[0] === undefined || centroid[1] === undefined) return;
            
            const topPoint = points.reduce((top, point) => 
                point[1] < top[1] ? point : top, points[0]);
            
            // Only add label if position is valid
            if (this.categoryLabelGroup && centroid[0] > 10 && centroid[1] > 10 && topPoint[1] > 10) {
                const labelY = topPoint[1] - dynamicPadding - 35;  // Much more spacing from hull
                this.categoryLabelGroup.append("text")
                    .attr("class", "category-label")
                    .attr("x", centroid[0])
                    .attr("y", labelY)  // More spacing from hull
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "700")
                    .style("fill", categoryColor.text || categoryColor.border)
                    .style("stroke", "#1a1a1a")
                    .style("stroke-width", "3px")
                    .style("paint-order", "stroke")
                    .style("pointer-events", "none")
                    .text(category.toUpperCase());
                
                // Store label bounds for repulsion with buffer
                this.categoryLabelBounds.push({
                    x: centroid[0],
                    y: labelY,
                    width: category.length * 14,  // Wider estimated width
                    height: 30,  // Taller height for buffer
                    category: category
                });
            }
        });
    }
    
    createBlobPath(points) {
        if (!points || points.length < 3) return "";
        
        // Close the path by adding the first point at the end
        const closedPoints = [...points, points[0], points[1]];
        
        // Use d3.curveCatmullRomClosed for smooth blob
        const lineGenerator = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .curve(d3.curveCatmullRomClosed.alpha(0.7));
        
        return lineGenerator(points);
    }
    
    expandHull(hull, padding) {
        if (!hull || hull.length < 3) return hull;
        
        const centroid = d3.polygonCentroid(hull);
        if (!centroid) return hull;
        
        // Expand points outward from centroid
        const expandedPoints = hull.map(point => {
            const dx = point[0] - centroid[0];
            const dy = point[1] - centroid[1];
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return point;
            
            // Add some variation to make shape more organic
            const variation = 1 + (Math.random() * 0.1 - 0.05); // ±5% variation
            const expandDistance = padding * variation;
            const scale = (distance + expandDistance) / distance;
            
            return [
                centroid[0] + dx * scale,
                centroid[1] + dy * scale
            ];
        });
        
        return expandedPoints;
    }
    
    getNodeRadius(node) {
        if (node.type === 'blog_post') {
            const connections = (node.in_degree || 0) + (node.out_degree || 0);
            return Math.max(
                this.CONFIG.NODE_MIN_RADIUS, 
                Math.min(this.CONFIG.NODE_MAX_RADIUS, this.CONFIG.NODE_MIN_RADIUS + connections * this.CONFIG.NODE_CONNECTION_MULTIPLIER)
            );
        } else if (node.type === 'external_link') {
            return this.CONFIG.NODE_EXTERNAL_RADIUS;
        }
        return this.CONFIG.NODE_BASE_RADIUS;
    }
    
    getNodeLabel(node) {
        if (node.type === 'blog_post') {
            const entryMatch = node.id.match(this.CONFIG.BLOG_ENTRY_PATTERN);
            return entryMatch ? entryMatch[1] : node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
        } else if (node.type === 'external_link') {
            return node.domain ? 
                node.domain.substring(0, this.CONFIG.LABEL_MAX_LENGTH) : 
                node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
        }
        return node.domain || node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
    }
    
    createDragBehavior() {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }
    
    // Simple tooltip methods
    showTooltip(event, node) {
        // Clear existing tooltip content
        this.tooltipGroup.selectAll("*").remove();
        
        // Prepare simple content
        let label = node.label;
        
        // For blog posts, strip the number prefix and format the title
        if (node.type === 'blog_post') {
            // Remove the leading numbers and underscore more robustly
            // Handles formats like "0001_title", "1_title", or even just starts with the title
            label = label.replace(/^\d{1,4}[_\-\s]*/, '');
            // Replace underscores with spaces and format title
            label = label.replace(/_/g, ' ');
            // Remove the file extension if present
            label = label.replace(/\.html?$/i, '');
            // Trim any leading/trailing whitespace
            label = label.trim();
            // Capitalize first letter if needed
            if (label.length > 0) {
                label = label.charAt(0).toUpperCase() + label.slice(1);
            }
        } else if (node.type === 'external_link' && node.domain) {
            label = node.domain;
        }
        
        // Calculate text dimensions
        const padding = 8;
        const textLength = label.length * 7; // Approximate character width
        const tooltipWidth = Math.min(200, Math.max(textLength + padding * 2, 60));
        const tooltipHeight = 24;
        
        // Calculate position
        const nodeX = node.x || 0;
        const nodeY = node.y || 0;
        const nodeRadius = this.getNodeRadius(node);
        
        let tooltipX = nodeX - tooltipWidth / 2;
        let tooltipY = nodeY - nodeRadius - tooltipHeight - 10;
        
        // Keep tooltip within viewport
        tooltipX = Math.max(10, Math.min(tooltipX, this.width - tooltipWidth - 10));
        if (tooltipY < 10) {
            tooltipY = nodeY + nodeRadius + 10;
        }
        
        // Render background
        this.tooltipGroup.append("rect")
            .attr("class", "tooltip-background")
            .attr("x", tooltipX)
            .attr("y", tooltipY)
            .attr("width", tooltipWidth)
            .attr("height", tooltipHeight);
        
        // Render text
        this.tooltipGroup.append("text")
            .attr("x", tooltipX + tooltipWidth / 2)
            .attr("y", tooltipY + tooltipHeight / 2)
            .text(label);
        
        // Show tooltip
        this.tooltipGroup.classed("hidden", false);
        this.tooltipGroup.classed("visible", true);
    }
    
    hideTooltip() {
        this.tooltipGroup.classed("visible", false);
        this.tooltipGroup.classed("hidden", true);
        this.tooltipGroup.selectAll("*").remove();
    }
    
    handleNodeClick(event, node) {
        // Navigate based on node type
        if (node.type === 'blog_post') {
            // Use category URL if available
            if (node.category) {
                window.open(`/b/${node.category}/${node.id}/`, '_blank');
            } else {
                window.open(`/b/${node.id}/`, '_blank');
            }
        } else if (node.url) {
            window.open(node.url, '_blank');
        }
    }
    
    createRippleEffect(x, y) {
        // Create effects group if it doesn't exist
        if (!this.effectsGroup) {
            this.effectsGroup = this.g.append("g").attr("class", "effects");
        }
        
        const ripple = this.effectsGroup.append("circle")
            .attr("class", "ripple-effect")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", 0);
        
        // Animate ripple
        ripple.transition()
            .duration(this.CONFIG.RIPPLE_DURATION)
            .ease(d3.easeCircleOut)
            .attr("r", this.CONFIG.RIPPLE_RADIUS)
            .style("opacity", 0)
            .remove();
    }
    
    highlightConnections(targetNode) {
        // Clear previous highlights
        this.clearHighlights();
        
        // Find connected nodes and links
        const connectedNodeIds = new Set();
        
        // Get the edges data from the simulation
        const edges = this.simulation ? this.simulation.force("link").links() : [];
        
        edges.forEach(edge => {
            const sourceId = edge.source.id || edge.source;
            const targetId = edge.target.id || edge.target;
            
            if (sourceId === targetNode.id || targetId === targetNode.id) {
                connectedNodeIds.add(sourceId);
                connectedNodeIds.add(targetId);
            }
        });
        
        // Highlight connected nodes
        this.node.classed("highlighted", d => connectedNodeIds.has(d.id));
        if (this.labels) {
            this.labels.classed("highlighted", d => connectedNodeIds.has(d.id));
        }
        
        // Highlight connected links
        this.link.classed("highlighted", d => {
            const sourceId = d.source.id || d.source;
            const targetId = d.target.id || d.target;
            return (sourceId === targetNode.id || targetId === targetNode.id);
        });
    }
    
    clearHighlights() {
        if (this.node) {
            this.node.classed("highlighted", false);
        }
        if (this.labels) {
            this.labels.classed("highlighted", false);
        }
        if (this.link) {
            this.link.classed("highlighted", false);
        }
    }
    
    handleResize() {
        this.width = this.container.node().clientWidth;
        this.height = this.container.node().clientHeight;
        
        this.svg.attr("viewBox", [0, 0, this.width, this.height]);
        
        // Update controls info position
        this.svg.select(".controls-info")
            .attr("y", this.height - 10);
        
        if (this.simulation) {
            this.simulation
                .force("center", d3.forceCenter(this.width / 2, this.height / 2))
                .alpha(0.3)
                .restart();
        }
        
        // Only re-fit if we haven't manually zoomed/panned (optional behavior)
        // Commenting out auto-refit on resize to preserve user's zoom state
        // setTimeout(() => this.fitGraphToView(), 500);
    }
}

// Initialize the visualization when the page loads
document.addEventListener('DOMContentLoaded', function() {
    try {
        new HomepageKnowledgeGraph();
    } catch (error) {
        console.error('Failed to initialize homepage knowledge graph:', error);
    }
});
</script>