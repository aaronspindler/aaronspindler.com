{% load static %}

<div class="knowledge-graph-section">
    <div id="knowledge-graph-container">
        <div id="loading">
            Loading knowledge graph...
        </div>
        <svg id="knowledge-graph-svg"></svg>
    </div>
</div>

<style>
/* Knowledge Graph Component Styles */
.knowledge-graph-section {
    margin: 1rem 0 2rem 0;
}

.blog-description {
    color: var(--text-color-alt);
    margin-bottom: 1.5rem;
    font-style: italic;
}

#knowledge-graph-container {
    position: relative;
    width: 100%;
    height: 400px;
    border: 1px solid var(--background-color-alt);
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 1rem;
}

#loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--background-color);
    color: var(--text-color);
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    z-index: 10;
    display: none;
}

#knowledge-graph-svg {
    width: 100%;
    height: 100%;
    background: var(--background-color);
}

/* Node and link styles */
.node {
    cursor: pointer;
    transition: all 0.2s ease;
}

.node:hover {
    stroke-width: 3px;
    stroke: var(--text-color);
}

.node.highlighted {
    stroke-width: 3px;
    stroke: #ff6b6b;
}

/* External link node specific styles */
.node.external_link {
    stroke-dasharray: 3,3;
    stroke-width: 2px;
}

.node.external_link:hover {
    stroke-width: 4px;
    stroke: var(--text-color);
}

.link {
    transition: stroke-opacity 0.2s ease;
}

.link.highlighted {
    stroke-opacity: 1;
    stroke-width: 3px;
}

/* External link edge specific styles */
.link.external {
    stroke-dasharray: 5,5;
    stroke-opacity: 0.8;
}

/* Node labels */
.node-label {
    font-family: var(--font-family);
    font-size: 11px;
    font-weight: var(--font-weight-medium);
    text-anchor: middle;
    pointer-events: none;
    fill: var(--text-color);
    stroke: var(--background-color);
    stroke-width: 3px;
    stroke-linejoin: round;
    paint-order: stroke;
}

/* Blog post number labels - distinct styling */
.node-label.blog-post-number {
    font-weight: bold;
    font-size: 13px;
    fill: #2196F3;
    stroke: var(--background-color);
    stroke-width: 4px;
    letter-spacing: 0.5px;
}

.node-label.highlighted {
    fill: #ff6b6b;
    stroke: var(--background-color);
}

.node-label.blog-post-number.highlighted {
    fill: #ff6b6b;
    font-weight: bold;
}

/* Tooltip styles */
.svg-tooltip {
    pointer-events: none;
}

.tooltip-background {
    fill: var(--background-color);
    stroke: var(--text-color);
    stroke-width: 1px;
    rx: 6;
    ry: 6;
}

.tooltip-arrow {
    fill: var(--background-color);
    stroke: var(--text-color);
    stroke-width: 1px;
}

.svg-tooltip text {
    dominant-baseline: middle;
    text-anchor: middle;
}

.svg-tooltip.hidden {
    opacity: 0;
    pointer-events: none;
}

/* Effects */
.ripple-effect {
    fill: none;
    stroke: var(--text-color);
    stroke-width: 2px;
    opacity: 0.6;
}

/* Force simulation adjustments */
.links line {
    stroke-linecap: round;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #knowledge-graph-container {
        height: 400px;
    }
    
    .node-label {
        font-size: 10px;
    }
}
</style>

<script>
class HomepageKnowledgeGraph {
    constructor() {
        // Configuration constants
        this.CONFIG = {
            // Dimensions
            DEFAULT_WIDTH: 800,
            DEFAULT_HEIGHT: 500,
            
            // Tooltip settings
            TOOLTIP_PADDING: 16,
            TOOLTIP_LINE_HEIGHT: 20,
            TOOLTIP_MAX_WIDTH: 350,
            TOOLTIP_BLOG_MAX_WIDTH: 450,
            TOOLTIP_MIN_WIDTH: 80,
            TOOLTIP_ARROW_SIZE: 8,
            TOOLTIP_OFFSET: 15,
            TOOLTIP_MARGIN: 15,
            
            // Font sizes
            TITLE_FONT_SIZE: '16px',
            SUBTITLE_FONT_SIZE: '14px',
            
            // Node settings
            NODE_MIN_RADIUS: 6,
            NODE_MAX_RADIUS: 16,
            NODE_EXTERNAL_RADIUS: 8,
            NODE_BASE_RADIUS: 5,
            NODE_CONNECTION_MULTIPLIER: 1.5,
            
            // Text display settings
            LABEL_MAX_LENGTH: 12,
            LABEL_SHORT_LENGTH: 8,
            BLOG_ENTRY_PATTERN: /^(\d{4})/,
            
            // Animation settings
            RIPPLE_DURATION: 1000,
            RIPPLE_RADIUS: 50,
            CLICK_DELAY: 200,
            RESIZE_DEBOUNCE: 150
        };
        
        this.svg = d3.select("#knowledge-graph-svg");
        this.container = d3.select("#knowledge-graph-container");
        this.loading = d3.select("#loading");
        
        // Get container dimensions
        const containerRect = this.container.node().getBoundingClientRect();
        this.width = containerRect.width || this.CONFIG.DEFAULT_WIDTH;
        this.height = containerRect.height || this.CONFIG.DEFAULT_HEIGHT;
        
        // Colors
        this.COLORS = {
            blogPost: '#4fc3f7',
            externalLink: '#ff9800',
            highlight: '#ff6b6b',
            white: '#fff'
        };
        
        // Force simulation configuration
        this.FORCE_CONFIG = {
            linkDistance: 80,
            chargeStrength: -250,
            collisionRadius: 20,
            centerStrength: 0.1
        };
        
        this.setupSVG();
        this.loadData();
        
        // Handle window resize with debouncing
        this.resizeTimeout = null;
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => this.handleResize(), this.CONFIG.RESIZE_DEBOUNCE);
        });
    }
    
    setupSVG() {
        this.svg.attr("viewBox", [0, 0, this.width, this.height])
            .attr("width", this.width)
            .attr("height", this.height);
        
        // Create zoom behavior
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                this.g.attr("transform", event.transform);
            });
        
        this.svg.call(this.zoom);
        
        // Create main group for all graph elements
        this.g = this.svg.append("g");
        
        // Create tooltip group
        this.tooltipGroup = this.svg.append("g")
            .attr("class", "svg-tooltip");
        
        // Add SVG filter for glow effect
        this.svg.append("defs").append("filter")
            .attr("id", "glow")
            .attr("x", "-50%")
            .attr("y", "-50%")
            .attr("width", "200%")
            .attr("height", "200%")
            .append("feGaussianBlur")
            .attr("stdDeviation", "2")
            .attr("result", "coloredBlur");
        
        this.svg.select("#glow").append("feMerge")
            .append("feMergeNode")
            .attr("in", "coloredBlur");
    }
    
    async loadData(forceRefresh = false) {
        try {
            this.loading.style("display", "block");
            
            // Add timestamp to prevent caching
            const timestamp = Date.now();
            const url = forceRefresh ?
                `/api/knowledge-graph/?refresh=true&t=${timestamp}` :
                `/api/knowledge-graph/?t=${timestamp}`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (result.status === 'success') {
                this.renderGraph(result.data);
            } else {
                console.error('API error:', result.error);
            }
        } catch (error) {
            console.error('Failed to load graph data:', error);
        } finally {
            this.loading.style("display", "none");
        }
    }
    
    renderGraph(data) {
        // Clear existing elements
        this.g.selectAll("*").remove();
        
        const { nodes, edges } = data;
        
        if (!nodes || nodes.length === 0) {
            return;
        }
        
        // Initialize node positions in a circle
        this.initializeNodePositions(nodes);
        
        // Create force simulation
        this.createForceSimulation(nodes, edges);
        
        // Create visual elements
        this.createLinks(edges);
        this.createNodes(nodes);
        this.createLabels(nodes);
        
        // Add event handlers
        this.addEventHandlers();
        
        // Start simulation
        this.simulation.alpha(1).restart();
    }
    
    initializeNodePositions(nodes) {
        const radius = Math.min(this.width, this.height) * 0.25;
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        nodes.forEach((node, i) => {
            const angle = (i / nodes.length) * 2 * Math.PI;
            node.x = centerX + radius * Math.cos(angle);
            node.y = centerY + radius * Math.sin(angle);
        });
    }
    
    createForceSimulation(nodes, edges) {
        this.simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(edges).id(d => d.id).distance(this.FORCE_CONFIG.linkDistance))
            .force("charge", d3.forceManyBody().strength(this.FORCE_CONFIG.chargeStrength))
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            .force("collision", d3.forceCollide().radius(this.FORCE_CONFIG.collisionRadius))
            .force("x", d3.forceX(this.width / 2).strength(this.FORCE_CONFIG.centerStrength))
            .force("y", d3.forceY(this.height / 2).strength(this.FORCE_CONFIG.centerStrength));
        
        // Update positions on simulation tick
        this.simulation.on("tick", () => this.updatePositions());
    }
    
    createLinks(edges) {
        this.link = this.g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(edges)
            .enter().append("line")
            .attr("class", d => `link ${d.type}`)
            .attr("stroke", d => d.type === 'internal' ? this.COLORS.blogPost : this.COLORS.externalLink)
            .attr("stroke-opacity", 0.6)
            .attr("stroke-width", d => d.type === 'internal' ? 2 : 1);
    }
    
    createNodes(nodes) {
        this.node = this.g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", d => `node ${d.type === 'blog_post' ? 'blog-post' : d.type}`)
            .attr("r", d => this.getNodeRadius(d))
            .attr("fill", d => d.type === 'blog_post' ? this.COLORS.blogPost : this.COLORS.externalLink)
            .attr("stroke", this.COLORS.white)
            .attr("stroke-width", 1.5)
            .call(this.createDragBehavior());
    }
    
    createLabels(nodes) {
        this.labels = this.g.append("g")
            .selectAll("text")
            .data(nodes)
            .enter().append("text")
            .attr("class", d => {
                // Add special class for blog post numbers
                if (d.type === 'blog_post') {
                    return "node-label blog-post-number";
                }
                return "node-label";
            })
            .attr("fill", "currentColor")
            .style("fill", d => {
                // Different color for blog post numbers
                if (d.type === 'blog_post') {
                    return "#2196F3";
                }
                return "var(--text-color)";
            })
            .style("stroke", "var(--background-color)")
            .style("stroke-width", d => d.type === 'blog_post' ? "4px" : "3px")
            .style("stroke-linejoin", "round")
            .style("paint-order", "stroke")
            .text(d => this.getNodeLabel(d))
            .style("display", "block");
    }
    
    addEventHandlers() {
        this.node
            .on("mouseover", (event, d) => {
                console.log('Mouseover on node:', d.id, d);
                this.showEnhancedTooltip(event, d);
                this.highlightConnections(d);
            })
            .on("mouseout", (event, d) => {
                console.log('Mouseout from node:', d.id);
                this.hideTooltip();
                this.clearHighlights();
            })
            .on("click", (event, d) => {
                console.log('Click on node:', d.id);
                this.handleEnhancedNodeClick(event, d);
            });
    }
    
    updatePositions() {
        this.link
            .attr("x1", d => d.source.x || 0)
            .attr("y1", d => d.source.y || 0)
            .attr("x2", d => d.target.x || 0)
            .attr("y2", d => d.target.y || 0);
        
        this.node
            .attr("cx", d => d.x || 0)
            .attr("cy", d => d.y || 0);
        
        this.labels
            .attr("x", d => d.x || 0)
            .attr("y", d => (d.y || 0) + 4);
    }
    
    getNodeRadius(node) {
        if (node.type === 'blog_post') {
            const connections = (node.in_degree || 0) + (node.out_degree || 0);
            return Math.max(
                this.CONFIG.NODE_MIN_RADIUS, 
                Math.min(this.CONFIG.NODE_MAX_RADIUS, this.CONFIG.NODE_MIN_RADIUS + connections * this.CONFIG.NODE_CONNECTION_MULTIPLIER)
            );
        } else if (node.type === 'external_link') {
            return this.CONFIG.NODE_EXTERNAL_RADIUS;
        }
        return this.CONFIG.NODE_BASE_RADIUS;
    }
    
    getNodeLabel(node) {
        if (node.type === 'blog_post') {
            const entryMatch = node.id.match(this.CONFIG.BLOG_ENTRY_PATTERN);
            return entryMatch ? entryMatch[1] : node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
        } else if (node.type === 'external_link') {
            return node.domain ? 
                node.domain.substring(0, this.CONFIG.LABEL_MAX_LENGTH) : 
                node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
        }
        return node.domain || node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
    }
    
    createDragBehavior() {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }
    
    // Tooltip methods
    showEnhancedTooltip(event, node) {
        // Clear existing tooltip content
        this.tooltipGroup.selectAll("*").remove();
        
        const tooltipContent = this.prepareTooltipContent(node);
        const dimensions = this.calculateTooltipDimensions(tooltipContent, node);
        const position = this.calculateTooltipPosition(node, dimensions);
        
        this.renderTooltip(position, dimensions, tooltipContent);
        
        // Show tooltip - remove hidden class and reset opacity
        this.tooltipGroup.classed("hidden", false);
        this.tooltipGroup.classed("visible", true);
        this.tooltipGroup.style("opacity", 1);
    }
    
    prepareTooltipContent(node) {
        let title, subtitle;
        
        if (node.type === 'blog_post') {
            title = node.label;
            subtitle = '';
        } else if (node.type === 'external_link') {
            title = node.domain || node.label;
            subtitle = 'External Link';
        } else {
            title = node.label;
            subtitle = '';
        }
        
        return { title, subtitle };
    }
    
    calculateTooltipDimensions(content, node) {
        // Set max width based on node type
        const maxWidth = node.type === 'blog_post' ?
            this.CONFIG.TOOLTIP_BLOG_MAX_WIDTH :
            this.CONFIG.TOOLTIP_MAX_WIDTH;
        
        // Calculate wrapped text dimensions
        const titleLines = this.wrapText(content.title, maxWidth - this.CONFIG.TOOLTIP_PADDING * 2);
        const subtitleLines = content.subtitle ?
            this.wrapText(content.subtitle, maxWidth - this.CONFIG.TOOLTIP_PADDING * 2) : [];
        
        // Store wrapped lines for later use
        content.titleLines = titleLines;
        content.subtitleLines = subtitleLines;
        
        // Calculate dimensions based on wrapped text
        const lineHeight = 20;
        const titleHeight = titleLines.length * lineHeight;
        const subtitleHeight = subtitleLines.length * lineHeight;
        
        const tooltipHeight = titleHeight +
            (content.subtitle ? subtitleHeight + 10 : 0) +
            this.CONFIG.TOOLTIP_PADDING * 2 + 8;
        
        return {
            width: maxWidth,
            height: tooltipHeight,
            titleHeight: titleHeight,
            subtitleHeight: subtitleHeight,
            lineHeight: lineHeight
        };
    }
    
    wrapText(text, maxWidth) {
        // Simple text wrapping algorithm
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        
        // Approximate character width
        const charWidth = 8;
        const maxCharsPerLine = Math.floor(maxWidth / charWidth);
        
        words.forEach(word => {
            const testLine = currentLine ? currentLine + ' ' + word : word;
            if (testLine.length <= maxCharsPerLine) {
                currentLine = testLine;
            } else {
                if (currentLine) {
                    lines.push(currentLine);
                }
                currentLine = word;
            }
        });
        
        if (currentLine) {
            lines.push(currentLine);
        }
        
        return lines.length > 0 ? lines : [text];
    }
    
    calculateTooltipPosition(node, dimensions) {
        const nodeX = node.x || 0;
        const nodeY = node.y || 0;
        
        // Position tooltip above the node
        let tooltipX = nodeX - dimensions.width / 2;
        let tooltipY = nodeY - this.getNodeRadius(node) - dimensions.height - this.CONFIG.TOOLTIP_OFFSET;
        
        // Ensure tooltip stays within viewport
        tooltipX = Math.max(
            this.CONFIG.TOOLTIP_MARGIN, 
            Math.min(tooltipX, this.width - dimensions.width - this.CONFIG.TOOLTIP_MARGIN)
        );
        tooltipY = Math.max(this.CONFIG.TOOLTIP_MARGIN, tooltipY);
        
        return { x: tooltipX, y: tooltipY, nodeX, nodeY };
    }
    
    renderTooltip(position, dimensions, content) {
        // Render background
        this.tooltipGroup.append("rect")
            .attr("class", "tooltip-background")
            .attr("x", position.x)
            .attr("y", position.y)
            .attr("width", dimensions.width)
            .attr("height", dimensions.height)
            .style("filter", "url(#glow)");
        
        // Render arrow
        const arrowY = position.y + dimensions.height;
        this.tooltipGroup.append("polygon")
            .attr("class", "tooltip-arrow")
            .attr("points", `${position.nodeX},${arrowY + this.CONFIG.TOOLTIP_ARROW_SIZE} ${position.nodeX - this.CONFIG.TOOLTIP_ARROW_SIZE},${arrowY} ${position.nodeX + this.CONFIG.TOOLTIP_ARROW_SIZE},${arrowY}`)
            .style("filter", "url(#glow)");
        
        // Render title with wrapped text
        const titleText = this.tooltipGroup.append("text")
            .attr("x", position.x + dimensions.width / 2)
            .attr("y", position.y + this.CONFIG.TOOLTIP_PADDING)
            .style("font-weight", "bold")
            .style("font-size", this.CONFIG.TITLE_FONT_SIZE)
            .style("font-family", "var(--font-family)")
            .style("fill", "var(--text-color)")
            .style("text-anchor", "middle")
            .style("pointer-events", "none");
        
        // Add each line as a tspan element for proper wrapping
        content.titleLines.forEach((line, i) => {
            titleText.append("tspan")
                .attr("x", position.x + dimensions.width / 2)
                .attr("dy", i === 0 ? 0 : dimensions.lineHeight)
                .text(line);
        });
        
        // Render subtitle if present with wrapped text
        if (content.subtitle && content.subtitleLines) {
            const subtitleText = this.tooltipGroup.append("text")
                .attr("x", position.x + dimensions.width / 2)
                .attr("y", position.y + this.CONFIG.TOOLTIP_PADDING + dimensions.titleHeight + 10)
                .style("font-size", this.CONFIG.SUBTITLE_FONT_SIZE)
                .style("font-family", "var(--font-family)")
                .style("opacity", "0.8")
                .style("fill", "var(--text-color)")
                .style("text-anchor", "middle")
                .style("pointer-events", "none");
            
            content.subtitleLines.forEach((line, i) => {
                subtitleText.append("tspan")
                    .attr("x", position.x + dimensions.width / 2)
                    .attr("dy", i === 0 ? 0 : dimensions.lineHeight)
                    .text(line);
            });
        }
    }
    
    hideTooltip() {
        // Remove visible class
        this.tooltipGroup.classed("visible", false);
        // Add hidden class for opacity transition
        this.tooltipGroup.classed("hidden", true);
        // Clear all tooltip content
        this.tooltipGroup.selectAll("*").remove();
        // Reset opacity
        this.tooltipGroup.style("opacity", 0);
    }
    
    handleEnhancedNodeClick(event, node) {
        // Create ripple effect
        this.createRippleEffect(node.x, node.y);
        
        // Navigate based on node type
        if (node.type === 'blog_post') {
            setTimeout(() => {
                window.open(`/b/${node.id}/`, '_blank');
            }, this.CONFIG.CLICK_DELAY);
        } else if (node.url) {
            setTimeout(() => {
                window.open(node.url, '_blank');
            }, this.CONFIG.CLICK_DELAY);
        }
    }
    
    createRippleEffect(x, y) {
        // Create effects group if it doesn't exist
        if (!this.effectsGroup) {
            this.effectsGroup = this.g.append("g").attr("class", "effects");
        }
        
        const ripple = this.effectsGroup.append("circle")
            .attr("class", "ripple-effect")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", 0);
        
        // Animate ripple
        ripple.transition()
            .duration(this.CONFIG.RIPPLE_DURATION)
            .ease(d3.easeCircleOut)
            .attr("r", this.CONFIG.RIPPLE_RADIUS)
            .style("opacity", 0)
            .remove();
    }
    
    highlightConnections(targetNode) {
        // Clear previous highlights
        this.clearHighlights();
        
        // Find connected nodes and links
        const connectedNodeIds = new Set();
        
        // Get the edges data from the simulation
        const edges = this.simulation ? this.simulation.force("link").links() : [];
        
        edges.forEach(edge => {
            const sourceId = edge.source.id || edge.source;
            const targetId = edge.target.id || edge.target;
            
            if (sourceId === targetNode.id || targetId === targetNode.id) {
                connectedNodeIds.add(sourceId);
                connectedNodeIds.add(targetId);
            }
        });
        
        // Highlight connected nodes
        this.node.classed("highlighted", d => connectedNodeIds.has(d.id));
        if (this.labels) {
            this.labels.classed("highlighted", d => connectedNodeIds.has(d.id));
        }
        
        // Highlight connected links
        this.link.classed("highlighted", d => {
            const sourceId = d.source.id || d.source;
            const targetId = d.target.id || d.target;
            return (sourceId === targetNode.id || targetId === targetNode.id);
        });
    }
    
    clearHighlights() {
        if (this.node) {
            this.node.classed("highlighted", false);
        }
        if (this.labels) {
            this.labels.classed("highlighted", false);
        }
        if (this.link) {
            this.link.classed("highlighted", false);
        }
    }
    
    handleResize() {
        this.width = this.container.node().clientWidth;
        this.height = this.container.node().clientHeight;
        
        this.svg.attr("viewBox", [0, 0, this.width, this.height]);
        
        if (this.simulation) {
            this.simulation
                .force("center", d3.forceCenter(this.width / 2, this.height / 2))
                .alpha(0.3)
                .restart();
        }
    }
}

// Initialize the visualization when the page loads
document.addEventListener('DOMContentLoaded', function() {
    try {
        new HomepageKnowledgeGraph();
    } catch (error) {
        console.error('Failed to initialize homepage knowledge graph:', error);
    }
});
</script>