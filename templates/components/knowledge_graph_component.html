{% load static %}

<!-- Knowledge Graph CSS -->
<link rel="stylesheet" href="{% static 'css/knowledge_graph.css' %}">

<div class="knowledge-graph-section">
    <div id="knowledge-graph-container">
        <div id="loading">
            Loading knowledge graph...
        </div>
        <svg id="knowledge-graph-svg"></svg>
    </div>
</div>

<script>
class HomepageKnowledgeGraph {
    constructor() {
        // Configuration constants
        this.CONFIG = {
            // Dimensions
            DEFAULT_WIDTH: 800,
            DEFAULT_HEIGHT: 500,
            
            // Tooltip settings
            TOOLTIP_PADDING: 20,
            TOOLTIP_LINE_HEIGHT: 22,
            TOOLTIP_MAX_WIDTH: 380,
            TOOLTIP_BLOG_MAX_WIDTH: 480,
            TOOLTIP_MIN_WIDTH: 100,
            TOOLTIP_ARROW_SIZE: 10,
            TOOLTIP_OFFSET: 20,
            TOOLTIP_MARGIN: 20,
            TOOLTIP_ANIMATION_DURATION: 250,
            
            // Font sizes
            TITLE_FONT_SIZE: '16px',
            SUBTITLE_FONT_SIZE: '14px',
            
            // Node settings
            NODE_MIN_RADIUS: 6,
            NODE_MAX_RADIUS: 16,
            NODE_EXTERNAL_RADIUS: 8,
            NODE_BASE_RADIUS: 5,
            NODE_CONNECTION_MULTIPLIER: 1.5,
            
            // Text display settings
            LABEL_MAX_LENGTH: 26,
            LABEL_SHORT_LENGTH: 18,
            BLOG_ENTRY_PATTERN: /^(\d{4})/,
            
            // Animation settings
            RIPPLE_DURATION: 1000,
            RIPPLE_RADIUS: 50,
            CLICK_DELAY: 200,
            RESIZE_DEBOUNCE: 150
        };
        
        this.svg = d3.select("#knowledge-graph-svg");
        this.container = d3.select("#knowledge-graph-container");
        this.loading = d3.select("#loading");
        
        // Get container dimensions
        const containerRect = this.container.node().getBoundingClientRect();
        this.width = containerRect.width || this.CONFIG.DEFAULT_WIDTH;
        this.height = containerRect.height || this.CONFIG.DEFAULT_HEIGHT;
        
        // Colors - adjusted for dark mode visibility
        this.COLORS = {
            blogPost: '#888',
            externalLink: '#aaa',
            highlight: '#fff',
            white: '#fff',
            // Category colors for nodes and hulls - brighter for dark mode
            categoryColors: {
                'tech': { 
                    node: '#5fb4b6', 
                    hull: 'rgba(95, 180, 182, 0.2)', 
                    border: 'rgba(95, 180, 182, 0.7)',
                    text: '#7dd8da'
                },
                'personal': { 
                    node: '#c594c5', 
                    hull: 'rgba(197, 148, 197, 0.2)', 
                    border: 'rgba(197, 148, 197, 0.7)',
                    text: '#dbb3db'
                },
                'projects': { 
                    node: '#fac863', 
                    hull: 'rgba(250, 200, 99, 0.2)', 
                    border: 'rgba(250, 200, 99, 0.7)',
                    text: '#ffd885'
                },
                'default': { 
                    node: '#999', 
                    hull: 'rgba(153, 153, 153, 0.2)', 
                    border: 'rgba(153, 153, 153, 0.7)',
                    text: '#bbb'
                }
            }
        };
        
        // Force simulation configuration
        this.FORCE_CONFIG = {
            linkDistance: 60,  // Reduced for tighter grouping
            chargeStrength: -150,  // Less repulsion for tighter clusters
            collisionRadius: 15,  // Smaller collision radius
            centerStrength: 0.05,  // Weaker center pull
            categoryStrength: 0.6,  // Moderate category clustering for flexibility
            basePadding: 40,  // Base padding for category hulls
            paddingPerNode: 8  // Additional padding per node
        };
        
        this.setupSVG();
        this.loadData();
        
        // Handle window resize with debouncing
        this.resizeTimeout = null;
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => this.handleResize(), this.CONFIG.RESIZE_DEBOUNCE);
        });
    }
    
    setupSVG() {
        this.svg.attr("viewBox", [0, 0, this.width, this.height])
            .attr("width", this.width)
            .attr("height", this.height);
        
        // Create zoom behavior
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", (event) => {
                this.g.attr("transform", event.transform);
            });
        
        this.svg.call(this.zoom);
        
        // Create main group for all graph elements
        this.g = this.svg.append("g");
        
        // Create tooltip group
        this.tooltipGroup = this.svg.append("g")
            .attr("class", "svg-tooltip");
        
        // No complex filters or gradients needed for simple tooltips
    }
    
    async loadData(forceRefresh = false) {
        try {
            this.loading.style("display", "block");
            
            // Add timestamp to prevent caching
            const timestamp = Date.now();
            const url = forceRefresh ?
                `/api/knowledge-graph/?refresh=true&t=${timestamp}` :
                `/api/knowledge-graph/?t=${timestamp}`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (result.status === 'success') {
                this.renderGraph(result.data);
            } else {
                console.error('API error:', result.error);
            }
        } catch (error) {
            console.error('Failed to load graph data:', error);
        } finally {
            this.loading.style("display", "none");
        }
    }
    
    renderGraph(data) {
        // Clear existing elements
        this.g.selectAll("*").remove();
        
        const { nodes, edges, categories } = data;
        
        if (!nodes || nodes.length === 0) {
            return;
        }
        
        // Store data for later use
        this.graphData = data;
        this.categories = categories || {};
        
        // Initialize node positions by category
        this.initializeNodePositionsByCategory(nodes);
        
        // Create force simulation with category clustering
        this.createForceSimulation(nodes, edges);
        
        // Create hull group first (background)
        this.hullGroup = this.g.append("g").attr("class", "hulls");
        
        // Create visual elements
        this.createLinks(edges);
        this.createNodes(nodes);
        this.createLabels(nodes);
        
        // Create a separate group for category labels (above everything)
        this.categoryLabelGroup = this.g.append("g").attr("class", "category-labels");
        
        // Add event handlers
        this.addEventHandlers();
        
        // Start simulation
        this.simulation.alpha(1).restart();
        
        // Delay initial category hull rendering until nodes are positioned
        setTimeout(() => {
            this.updateCategoryHulls();
        }, 100);
    }
    
    initializeNodePositionsByCategory(nodes) {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const categoryGroups = {};
        
        // Group nodes by category
        nodes.forEach(node => {
            const category = node.category || 'uncategorized';
            if (!categoryGroups[category]) {
                categoryGroups[category] = [];
            }
            categoryGroups[category].push(node);
        });
        
        // Store category centers for later use
        this.categoryCenters = {};
        
        // Position each category group in a different area
        const categories = Object.keys(categoryGroups);
        const angleStep = (2 * Math.PI) / Math.max(categories.length, 1);
        const groupRadius = Math.min(this.width, this.height) * 0.25;
        
        categories.forEach((category, catIndex) => {
            const categoryAngle = catIndex * angleStep;
            const groupCenterX = centerX + groupRadius * Math.cos(categoryAngle);
            const groupCenterY = centerY + groupRadius * Math.sin(categoryAngle);
            
            // Store category center
            this.categoryCenters[category] = { x: groupCenterX, y: groupCenterY };
            
            // Position nodes in a tight circular pattern within the category
            const nodesInCategory = categoryGroups[category];
            const nodeCount = nodesInCategory.length;
            
            if (nodeCount === 1) {
                // Single node at center
                nodesInCategory[0].x = groupCenterX;
                nodesInCategory[0].y = groupCenterY;
            } else {
                // Multiple nodes in concentric circles
                const maxRadius = this.FORCE_CONFIG.categoryRadius * 0.4; // Use 40% of category radius
                let placedNodes = 0;
                let currentRadius = 0;
                let ring = 0;
                
                while (placedNodes < nodeCount) {
                    const nodesInRing = ring === 0 ? 1 : Math.min(6 * ring, nodeCount - placedNodes);
                    currentRadius = ring === 0 ? 0 : (maxRadius * ring) / Math.ceil(Math.sqrt(nodeCount));
                    
                    for (let i = 0; i < nodesInRing && placedNodes < nodeCount; i++) {
                        const angle = (i / nodesInRing) * 2 * Math.PI;
                        const node = nodesInCategory[placedNodes];
                        node.x = groupCenterX + currentRadius * Math.cos(angle);
                        node.y = groupCenterY + currentRadius * Math.sin(angle);
                        placedNodes++;
                    }
                    ring++;
                }
            }
        });
    }
    
    createForceSimulation(nodes, edges) {
        // Use stored category centers
        const categoryCenters = this.categoryCenters || this.calculateCategoryCenters();
        
        this.simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(edges).id(d => d.id)
                .distance(d => {
                    // Shorter links within same category
                    if (d.source.category && d.target.category && 
                        d.source.category === d.target.category) {
                        return this.FORCE_CONFIG.linkDistance * 0.7;
                    }
                    return this.FORCE_CONFIG.linkDistance;
                })
                .strength(d => {
                    // Stronger links within same category
                    if (d.source.category && d.target.category && 
                        d.source.category === d.target.category) {
                        return 1.5;
                    }
                    return 1;
                })
            )
            .force("charge", d3.forceManyBody()
                .strength(d => {
                    // Less repulsion between nodes in same category
                    return d.category ? this.FORCE_CONFIG.chargeStrength * 0.5 : this.FORCE_CONFIG.chargeStrength;
                })
            )
            .force("collision", d3.forceCollide().radius(this.FORCE_CONFIG.collisionRadius))
            // Moderate category clustering for organic shapes
            .force("categoryX", d3.forceX(d => {
                const category = d.category || 'uncategorized';
                return categoryCenters[category]?.x || this.width / 2;
            }).strength(this.FORCE_CONFIG.categoryStrength))
            .force("categoryY", d3.forceY(d => {
                const category = d.category || 'uncategorized';
                return categoryCenters[category]?.y || this.height / 2;
            }).strength(this.FORCE_CONFIG.categoryStrength));
        
        // Update positions on simulation tick with throttled hull updates
        this.tickCount = 0;
        this.simulation.on("tick", () => {
            this.updatePositions();
            // Update hulls every 3 ticks for smoother performance
            this.tickCount++;
            if (this.tickCount % 3 === 0) {
                this.updateCategoryHulls();
            }
        });
    }
    
    calculateCategoryCenters() {
        const centers = {};
        const categories = Object.keys(this.categories || {});
        const angleStep = (2 * Math.PI) / Math.max(categories.length, 1);
        const radius = Math.min(this.width, this.height) * 0.25;
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        categories.forEach((category, index) => {
            const angle = index * angleStep;
            centers[category] = {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            };
        });
        
        // Add center for uncategorized nodes
        centers['uncategorized'] = { x: centerX, y: centerY };
        
        return centers;
    }
    
    createLinks(edges) {
        this.link = this.g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(edges)
            .enter().append("line")
            .attr("class", d => `link ${d.type}`)
            .attr("stroke", d => d.type === 'internal' ? this.COLORS.blogPost : this.COLORS.externalLink)
            .attr("stroke-opacity", 0.6)
            .attr("stroke-width", d => d.type === 'internal' ? 2 : 1);
    }
    
    createNodes(nodes) {
        this.node = this.g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", d => {
                if (d.type === 'blog_post') return `node blog-post ${d.category || 'uncategorized'}`;
                return `node ${d.type}`;
            })
            .attr("r", d => this.getNodeRadius(d))
            .attr("fill", d => {
                if (d.type === 'blog_post') {
                    const category = d.category || 'default';
                    const categoryColor = this.COLORS.categoryColors[category] || this.COLORS.categoryColors.default;
                    return categoryColor.node;
                }
                return this.COLORS.externalLink;
            })
            .attr("stroke", this.COLORS.white)
            .attr("stroke-width", 1.5)
            .call(this.createDragBehavior());
    }
    
    createLabels(nodes) {
        this.labels = this.g.append("g")
            .selectAll("text")
            .data(nodes)
            .enter().append("text")
            .attr("class", d => {
                if (d.type === 'blog_post') {
                    return "node-label blog-post-number";
                }
                return "node-label";
            })
            .attr("fill", "currentColor")
            .style("fill", "var(--text-color)")
            .style("stroke", "var(--background-color)")
            .style("stroke-width", d => d.type === 'blog_post' ? "4px" : "3px")
            .style("stroke-linejoin", "round")
            .style("paint-order", "stroke")
            .text(d => this.getNodeLabel(d))
            .style("display", "block");
    }
    
    addEventHandlers() {
        this.node
            .on("mouseover", (event, d) => {
                this.showTooltip(event, d);
                this.highlightConnections(d);
            })
            .on("mouseout", (event, d) => {
                this.hideTooltip();
                this.clearHighlights();
            })
            .on("click", (event, d) => {
                this.handleNodeClick(event, d);
            });
    }
    
    updatePositions() {
        this.link
            .attr("x1", d => d.source.x || 0)
            .attr("y1", d => d.source.y || 0)
            .attr("x2", d => d.target.x || 0)
            .attr("y2", d => d.target.y || 0);
        
        this.node
            .attr("cx", d => d.x || 0)
            .attr("cy", d => d.y || 0);
        
        this.labels
            .attr("x", d => d.x || 0)
            .attr("y", d => (d.y || 0) + 4);
    }
    
    updateCategoryHulls() {
        if (!this.hullGroup) return;
        
        // Group nodes by category
        const categoryGroups = {};
        const nodes = this.simulation ? this.simulation.nodes() : [];
        
        nodes.forEach(node => {
            if (node.type === 'blog_post' && node.category) {
                // Only add nodes with valid positions
                if (node.x !== undefined && node.y !== undefined && 
                    !isNaN(node.x) && !isNaN(node.y) &&
                    (Math.abs(node.x) > 1 || Math.abs(node.y) > 1)) {  // Not at origin
                    if (!categoryGroups[node.category]) {
                        categoryGroups[node.category] = [];
                    }
                    categoryGroups[node.category].push([node.x, node.y]);
                }
            }
        });
        
        // Clear existing hulls and labels
        this.hullGroup.selectAll("*").remove();
        if (this.categoryLabelGroup) {
            this.categoryLabelGroup.selectAll("*").remove();
        }
        
        // Draw organic hulls for each category
        Object.entries(categoryGroups).forEach(([category, points]) => {
            // Skip if no points or all points are invalid
            if (points.length === 0) return;
            
            // Validate points - filter out any remaining invalid ones
            const validPoints = points.filter(([x, y]) => 
                x !== undefined && y !== undefined && 
                !isNaN(x) && !isNaN(y) &&
                (Math.abs(x) > 1 || Math.abs(y) > 1)
            );
            
            if (validPoints.length === 0) return;
            points = validPoints;  // Use only valid points
            
            const categoryData = this.categories[category] || {};
            const categoryColor = this.COLORS.categoryColors[category] || this.COLORS.categoryColors.default;
            
            // Calculate dynamic padding based on node count
            const dynamicPadding = this.FORCE_CONFIG.basePadding + 
                (points.length * this.FORCE_CONFIG.paddingPerNode);
            
            if (points.length === 1) {
                // Single node - draw a circle around it
                const [x, y] = points[0];
                
                // Validate position before drawing
                if (x === undefined || y === undefined || isNaN(x) || isNaN(y)) return;
                
                this.hullGroup.append("circle")
                    .attr("class", `category-hull hull-${category}`)
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", dynamicPadding)
                    .style("fill", categoryColor.hull)
                    .style("stroke", categoryColor.border)
                    .style("stroke-width", 2)
                    .style("opacity", 0.8);
                
                // Add label for single node at top
                if (this.categoryLabelGroup && x > 10 && y > 10) {  // Only if position is reasonable
                    this.categoryLabelGroup.append("text")
                        .attr("class", "category-label")
                        .attr("x", x)
                        .attr("y", y - dynamicPadding - 5)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("font-weight", "700")
                        .style("fill", categoryColor.text || categoryColor.border)
                        .style("stroke", "#1a1a1a")
                        .style("stroke-width", "3px")
                        .style("paint-order", "stroke")
                        .style("pointer-events", "none")
                        .text(category.toUpperCase());
                }
                    
            } else if (points.length === 2) {
                // Two nodes - draw an ellipse/capsule shape
                const [x1, y1] = points[0];
                const [x2, y2] = points[1];
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                this.hullGroup.append("ellipse")
                    .attr("class", `category-hull hull-${category}`)
                    .attr("cx", midX)
                    .attr("cy", midY)
                    .attr("rx", distance / 2 + dynamicPadding)
                    .attr("ry", dynamicPadding)
                    .attr("transform", `rotate(${angle} ${midX} ${midY})`)
                    .style("fill", categoryColor.hull)
                    .style("stroke", categoryColor.border)
                    .style("stroke-width", 2)
                    .style("opacity", 0.8);
                
                // Add label for two nodes at top
                if (this.categoryLabelGroup && midX > 10 && midY > 10) {  // Only if position is reasonable
                    const topY = Math.min(y1, y2) - dynamicPadding - 5;
                    this.categoryLabelGroup.append("text")
                        .attr("class", "category-label")
                        .attr("x", midX)
                        .attr("y", topY)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("font-weight", "700")
                        .style("fill", categoryColor.text || categoryColor.border)
                        .style("stroke", "#1a1a1a")
                        .style("stroke-width", "3px")
                        .style("paint-order", "stroke")
                        .style("pointer-events", "none")
                        .text(category.toUpperCase());
                }
                    
            } else {
                // Multiple nodes - create organic blob shape
                const hull = d3.polygonHull(points);
                if (!hull) return;
                
                // Expand hull with dynamic padding
                const expandedHull = this.expandHull(hull, dynamicPadding);
                if (!expandedHull) return;
                
                // Create smooth blob path using Catmull-Rom curve
                const pathData = this.createBlobPath(expandedHull);
                
                // Draw the organic shape
                this.hullGroup.append("path")
                    .attr("class", `category-hull hull-${category}`)
                    .attr("d", pathData)
                    .style("fill", categoryColor.hull)
                    .style("stroke", categoryColor.border)
                    .style("stroke-width", 2)
                    .style("stroke-linejoin", "round")
                    .style("opacity", 0.8);
            }
            
            // Add category label at the top of the group
            const centroid = points.length > 0 ? d3.polygonCentroid(points) : null;
            if (!centroid || centroid[0] === undefined || centroid[1] === undefined) return;
            
            const topPoint = points.reduce((top, point) => 
                point[1] < top[1] ? point : top, points[0]);
            
            // Only add label if position is valid
            if (this.categoryLabelGroup && centroid[0] > 10 && centroid[1] > 10 && topPoint[1] > 10) {
                this.categoryLabelGroup.append("text")
                    .attr("class", "category-label")
                    .attr("x", centroid[0])
                    .attr("y", topPoint[1] - dynamicPadding - 5)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "700")
                    .style("fill", categoryColor.text || categoryColor.border)
                    .style("stroke", "#1a1a1a")
                    .style("stroke-width", "3px")
                    .style("paint-order", "stroke")
                    .style("pointer-events", "none")
                    .text(category.toUpperCase());
            }
        });
    }
    
    createBlobPath(points) {
        if (!points || points.length < 3) return "";
        
        // Close the path by adding the first point at the end
        const closedPoints = [...points, points[0], points[1]];
        
        // Use d3.curveCatmullRomClosed for smooth blob
        const lineGenerator = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .curve(d3.curveCatmullRomClosed.alpha(0.7));
        
        return lineGenerator(points);
    }
    
    expandHull(hull, padding) {
        if (!hull || hull.length < 3) return hull;
        
        const centroid = d3.polygonCentroid(hull);
        if (!centroid) return hull;
        
        // Expand points outward from centroid
        const expandedPoints = hull.map(point => {
            const dx = point[0] - centroid[0];
            const dy = point[1] - centroid[1];
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return point;
            
            // Add some variation to make shape more organic
            const variation = 1 + (Math.random() * 0.1 - 0.05); // Â±5% variation
            const expandDistance = padding * variation;
            const scale = (distance + expandDistance) / distance;
            
            return [
                centroid[0] + dx * scale,
                centroid[1] + dy * scale
            ];
        });
        
        return expandedPoints;
    }
    
    getNodeRadius(node) {
        if (node.type === 'blog_post') {
            const connections = (node.in_degree || 0) + (node.out_degree || 0);
            return Math.max(
                this.CONFIG.NODE_MIN_RADIUS, 
                Math.min(this.CONFIG.NODE_MAX_RADIUS, this.CONFIG.NODE_MIN_RADIUS + connections * this.CONFIG.NODE_CONNECTION_MULTIPLIER)
            );
        } else if (node.type === 'external_link') {
            return this.CONFIG.NODE_EXTERNAL_RADIUS;
        }
        return this.CONFIG.NODE_BASE_RADIUS;
    }
    
    getNodeLabel(node) {
        if (node.type === 'blog_post') {
            const entryMatch = node.id.match(this.CONFIG.BLOG_ENTRY_PATTERN);
            return entryMatch ? entryMatch[1] : node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
        } else if (node.type === 'external_link') {
            return node.domain ? 
                node.domain.substring(0, this.CONFIG.LABEL_MAX_LENGTH) : 
                node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
        }
        return node.domain || node.label.substring(0, this.CONFIG.LABEL_SHORT_LENGTH);
    }
    
    createDragBehavior() {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }
    
    // Simple tooltip methods
    showTooltip(event, node) {
        // Clear existing tooltip content
        this.tooltipGroup.selectAll("*").remove();
        
        // Prepare simple content
        let label = node.label;
        
        // For blog posts, strip the number prefix and format the title
        if (node.type === 'blog_post') {
            // Remove the leading numbers and underscore more robustly
            // Handles formats like "0001_title", "1_title", or even just starts with the title
            label = label.replace(/^\d{1,4}[_\-\s]*/, '');
            // Replace underscores with spaces and format title
            label = label.replace(/_/g, ' ');
            // Remove the file extension if present
            label = label.replace(/\.html?$/i, '');
            // Trim any leading/trailing whitespace
            label = label.trim();
            // Capitalize first letter if needed
            if (label.length > 0) {
                label = label.charAt(0).toUpperCase() + label.slice(1);
            }
        } else if (node.type === 'external_link' && node.domain) {
            label = node.domain;
        }
        
        // Calculate text dimensions
        const padding = 8;
        const textLength = label.length * 7; // Approximate character width
        const tooltipWidth = Math.min(200, Math.max(textLength + padding * 2, 60));
        const tooltipHeight = 24;
        
        // Calculate position
        const nodeX = node.x || 0;
        const nodeY = node.y || 0;
        const nodeRadius = this.getNodeRadius(node);
        
        let tooltipX = nodeX - tooltipWidth / 2;
        let tooltipY = nodeY - nodeRadius - tooltipHeight - 10;
        
        // Keep tooltip within viewport
        tooltipX = Math.max(10, Math.min(tooltipX, this.width - tooltipWidth - 10));
        if (tooltipY < 10) {
            tooltipY = nodeY + nodeRadius + 10;
        }
        
        // Render background
        this.tooltipGroup.append("rect")
            .attr("class", "tooltip-background")
            .attr("x", tooltipX)
            .attr("y", tooltipY)
            .attr("width", tooltipWidth)
            .attr("height", tooltipHeight);
        
        // Render text
        this.tooltipGroup.append("text")
            .attr("x", tooltipX + tooltipWidth / 2)
            .attr("y", tooltipY + tooltipHeight / 2)
            .text(label);
        
        // Show tooltip
        this.tooltipGroup.classed("hidden", false);
        this.tooltipGroup.classed("visible", true);
    }
    
    hideTooltip() {
        this.tooltipGroup.classed("visible", false);
        this.tooltipGroup.classed("hidden", true);
        this.tooltipGroup.selectAll("*").remove();
    }
    
    handleNodeClick(event, node) {
        // Navigate based on node type
        if (node.type === 'blog_post') {
            // Use category URL if available
            if (node.category) {
                window.open(`/b/${node.category}/${node.id}/`, '_blank');
            } else {
                window.open(`/b/${node.id}/`, '_blank');
            }
        } else if (node.url) {
            window.open(node.url, '_blank');
        }
    }
    
    createRippleEffect(x, y) {
        // Create effects group if it doesn't exist
        if (!this.effectsGroup) {
            this.effectsGroup = this.g.append("g").attr("class", "effects");
        }
        
        const ripple = this.effectsGroup.append("circle")
            .attr("class", "ripple-effect")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", 0);
        
        // Animate ripple
        ripple.transition()
            .duration(this.CONFIG.RIPPLE_DURATION)
            .ease(d3.easeCircleOut)
            .attr("r", this.CONFIG.RIPPLE_RADIUS)
            .style("opacity", 0)
            .remove();
    }
    
    highlightConnections(targetNode) {
        // Clear previous highlights
        this.clearHighlights();
        
        // Find connected nodes and links
        const connectedNodeIds = new Set();
        
        // Get the edges data from the simulation
        const edges = this.simulation ? this.simulation.force("link").links() : [];
        
        edges.forEach(edge => {
            const sourceId = edge.source.id || edge.source;
            const targetId = edge.target.id || edge.target;
            
            if (sourceId === targetNode.id || targetId === targetNode.id) {
                connectedNodeIds.add(sourceId);
                connectedNodeIds.add(targetId);
            }
        });
        
        // Highlight connected nodes
        this.node.classed("highlighted", d => connectedNodeIds.has(d.id));
        if (this.labels) {
            this.labels.classed("highlighted", d => connectedNodeIds.has(d.id));
        }
        
        // Highlight connected links
        this.link.classed("highlighted", d => {
            const sourceId = d.source.id || d.source;
            const targetId = d.target.id || d.target;
            return (sourceId === targetNode.id || targetId === targetNode.id);
        });
    }
    
    clearHighlights() {
        if (this.node) {
            this.node.classed("highlighted", false);
        }
        if (this.labels) {
            this.labels.classed("highlighted", false);
        }
        if (this.link) {
            this.link.classed("highlighted", false);
        }
    }
    
    handleResize() {
        this.width = this.container.node().clientWidth;
        this.height = this.container.node().clientHeight;
        
        this.svg.attr("viewBox", [0, 0, this.width, this.height]);
        
        if (this.simulation) {
            this.simulation
                .force("center", d3.forceCenter(this.width / 2, this.height / 2))
                .alpha(0.3)
                .restart();
        }
    }
}

// Initialize the visualization when the page loads
document.addEventListener('DOMContentLoaded', function() {
    try {
        new HomepageKnowledgeGraph();
    } catch (error) {
        console.error('Failed to initialize homepage knowledge graph:', error);
    }
});
</script>