{% extends "_base.html" %}

{% block title %}Knowledge Graph{% endblock %}

{% block content %}
<div>
    <h1>Knowledge Graph</h1>
</div>

<div id="knowledge-graph-container">
    <div id="loading">
        Loading knowledge graph...
    </div>
    <svg id="knowledge-graph-svg"></svg>
</div>

<style>
/* Knowledge Graph specific styles */
#knowledge-graph-container {
    position: relative;
    width: 100%;
    height: 600px;
    border: 1px solid var(--background-color-alt);
    border-radius: 8px;
    overflow: hidden;
}

#loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--background-color);
    color: var(--text-color);
    padding: 1rem;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    z-index: 10;
    display: none;
}

#knowledge-graph-svg {
    width: 100%;
    height: 100%;
    background: var(--background-color);
}

/* Node and link styles */
.node {
    cursor: pointer;
    transition: all 0.2s ease;
}

.node:hover {
    stroke-width: 3px;
    stroke: var(--text-color);
}

.node.highlighted {
    stroke-width: 3px;
    stroke: #ff6b6b;
}

.link {
    transition: stroke-opacity 0.2s ease;
}

.link.highlighted {
    stroke-opacity: 1;
    stroke-width: 3px;
}

/* Node labels */
.node-label {
    font-family: var(--font-family);
    font-size: 12px;
    font-weight: var(--font-weight-medium);
    text-anchor: middle;
    pointer-events: none;
    fill: var(--text-color);
    stroke: var(--background-color);
    stroke-width: 3px;
    stroke-linejoin: round;
    paint-order: stroke;
}

.node-label.highlighted {
    fill: #ff6b6b;
    stroke: var(--background-color);
}

/* Tooltip styles */
.svg-tooltip {
    pointer-events: none;
}

.tooltip-background {
    fill: var(--background-color);
    stroke: var(--text-color);
    stroke-width: 1px;
    rx: 6;
    ry: 6;
}

.tooltip-arrow {
    fill: var(--background-color);
    stroke: var(--text-color);
    stroke-width: 1px;
}

/* Effects */
.ripple-effect {
    fill: none;
    stroke: var(--text-color);
    stroke-width: 2px;
    opacity: 0.6;
}

/* Force simulation adjustments */
.links line {
    stroke-linecap: round;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #knowledge-graph-container {
        height: 400px;
    }
    
    .node-label {
        font-size: 10px;
    }
}
</style>
{% endblock %}

{% block javascript %}
{{ block.super }}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
class KnowledgeGraphVisualization {
    constructor() {
        this.svg = d3.select("#knowledge-graph-svg");
        this.container = d3.select("#knowledge-graph-container");
        this.loading = d3.select("#loading");
        
        // Get container dimensions
        const containerRect = this.container.node().getBoundingClientRect();
        this.width = containerRect.width || 800;
        this.height = containerRect.height || 600;
        
        this.showLabels = true;
        this.showExternal = true;
        
        // Constants
        this.COLORS = {
            blogPost: '#4fc3f7',
            external: '#ff9800',
            highlight: '#ff6b6b',
            white: '#fff'
        };
        
        this.FORCE_CONFIG = {
            linkDistance: 100,
            chargeStrength: -300,
            collisionRadius: 25,
            centerStrength: 0.1
        };
        
        this.setupSVG();
        this.loadData();
        
        // Handle window resize with debouncing
        this.resizeTimeout = null;
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => this.handleResize(), 150);
        });
    }
    
    setupSVG() {
        this.svg.attr("viewBox", [0, 0, this.width, this.height])
            .attr("width", this.width)
            .attr("height", this.height);
        
        // Create zoom behavior
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                this.g.attr("transform", event.transform);
            });
        
        this.svg.call(this.zoom);
        
        // Create main group for all graph elements
        this.g = this.svg.append("g");
        
        // Create tooltip group
        this.tooltipGroup = this.svg.append("g")
            .attr("class", "svg-tooltip");
    }
    
    async loadData(forceRefresh = false) {
        try {
            this.loading.style("display", "block");
            
            const url = forceRefresh ?
                '/api/knowledge-graph/?refresh=true' :
                '/api/knowledge-graph/';
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            
            if (result.status === 'success') {
                this.renderGraph(result.data);
            } else {
                console.error('API error:', result.error);
            }
        } catch (error) {
            console.error('Failed to load graph data:', error);
        } finally {
            this.loading.style("display", "none");
        }
    }
    
    renderGraph(data) {
        // Clear existing elements
        this.g.selectAll("*").remove();
        
        const { nodes, edges } = data;
        
        if (!nodes || nodes.length === 0) {
            return;
        }
        
        // Initialize node positions in a circle
        this.initializeNodePositions(nodes);
        
        // Create force simulation
        this.createForceSimulation(nodes, edges);
        
        // Create visual elements
        this.createLinks(edges);
        this.createNodes(nodes);
        this.createLabels(nodes);
        
        // Add event handlers
        this.addEventHandlers();
        
        // Start simulation
        this.simulation.alpha(1).restart();
        
        this.updateExternalVisibility();
    }
    
    initializeNodePositions(nodes) {
        const radius = Math.min(this.width, this.height) * 0.3;
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        
        nodes.forEach((node, i) => {
            const angle = (i / nodes.length) * 2 * Math.PI;
            node.x = centerX + radius * Math.cos(angle);
            node.y = centerY + radius * Math.sin(angle);
        });
    }
    
    createForceSimulation(nodes, edges) {
        this.simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(edges).id(d => d.id).distance(this.FORCE_CONFIG.linkDistance))
            .force("charge", d3.forceManyBody().strength(this.FORCE_CONFIG.chargeStrength))
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            .force("collision", d3.forceCollide().radius(this.FORCE_CONFIG.collisionRadius))
            .force("x", d3.forceX(this.width / 2).strength(this.FORCE_CONFIG.centerStrength))
            .force("y", d3.forceY(this.height / 2).strength(this.FORCE_CONFIG.centerStrength));
        
        // Update positions on simulation tick
        this.simulation.on("tick", () => this.updatePositions());
    }
    
    createLinks(edges) {
        this.link = this.g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(edges)
            .enter().append("line")
            .attr("class", d => `link ${d.type}`)
            .attr("stroke", d => d.type === 'internal' ? this.COLORS.blogPost : this.COLORS.external)
            .attr("stroke-opacity", 0.6)
            .attr("stroke-width", d => d.type === 'internal' ? 2 : 1);
    }
    
    createNodes(nodes) {
        this.node = this.g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", d => `node ${d.type === 'blog_post' ? 'blog-post' : d.type}`)
            .attr("r", d => this.getNodeRadius(d))
            .attr("fill", d => d.type === 'blog_post' ? this.COLORS.blogPost : this.COLORS.external)
            .attr("stroke", this.COLORS.white)
            .attr("stroke-width", 1.5)
            .call(this.createDragBehavior());
    }
    
    createLabels(nodes) {
        this.labels = this.g.append("g")
            .selectAll("text")
            .data(nodes)
            .enter().append("text")
            .attr("class", "node-label")
            .attr("fill", "currentColor")
            .style("fill", "var(--text-color)")
            .style("stroke", "var(--background-color)")
            .style("stroke-width", "3px")
            .style("stroke-linejoin", "round")
            .style("paint-order", "stroke")
            .text(d => this.getNodeLabel(d))
            .style("display", this.showLabels ? "block" : "none");
    }
    
    addEventHandlers() {
        this.node
            .on("mouseover", (event, d) => {
                this.showEnhancedTooltip(event, d);
                this.highlightConnections(d);
            })
            .on("mouseout", (event, d) => {
                this.hideTooltip();
                this.clearHighlights();
            })
            .on("click", (event, d) => {
                this.handleEnhancedNodeClick(event, d);
            });
    }
    
    updatePositions() {
        this.link
            .attr("x1", d => d.source.x || 0)
            .attr("y1", d => d.source.y || 0)
            .attr("x2", d => d.target.x || 0)
            .attr("y2", d => d.target.y || 0);
        
        this.node
            .attr("cx", d => d.x || 0)
            .attr("cy", d => d.y || 0);
        
        this.labels
            .attr("x", d => d.x || 0)
            .attr("y", d => (d.y || 0) + 4);
    }
    
    getNodeRadius(node) {
        if (node.type === 'blog_post') {
            const connections = (node.in_degree || 0) + (node.out_degree || 0);
            return Math.max(8, Math.min(20, 8 + connections * 2));
        }
        return 6;
    }
    
    getNodeLabel(node) {
        if (node.type === 'blog_post') {
            const entryMatch = node.id.match(/^(\d{4})/);
            return entryMatch ? entryMatch[1] : node.label.substring(0, 10);
        }
        return node.domain || node.label.substring(0, 10);
    }
    
    createDragBehavior() {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }
    
    showEnhancedTooltip(event, node) {
        // Clear existing tooltip content
        this.tooltipGroup.selectAll("*").remove();
        
        // Enhanced tooltip content
        const title = node.type === 'blog_post' ? node.label : node.domain;
        const subtitle = node.type === 'blog_post' ? '' : 'External Link';
        
        // Get node position in SVG coordinates
        const nodeX = node.x || 0;
        const nodeY = node.y || 0;
        
        // Create temporary text elements to measure dimensions
        const tempTitle = this.tooltipGroup.append("text")
            .style("font-weight", "bold")
            .text(title)
            .style("opacity", 0);
        
        const tempSubtitle = this.tooltipGroup.append("text")
            .style("font-size", "11px")
            .text(subtitle)
            .style("opacity", 0);
        
        const titleBBox = tempTitle.node().getBBox();
        const subtitleBBox = tempSubtitle.node().getBBox();
        
        tempTitle.remove();
        tempSubtitle.remove();
        
        // Calculate tooltip dimensions
        const padding = 12;
        const lineHeight = 18;
        const tooltipWidth = Math.max(titleBBox.width, subtitleBBox.width) + padding * 2;
        const tooltipHeight = titleBBox.height + (subtitle ? subtitleBBox.height + lineHeight : 0) + padding * 2 + 4;
        
        // Position tooltip above the node with better positioning
        let tooltipX = nodeX - tooltipWidth / 2;
        let tooltipY = nodeY - this.getNodeRadius(node) - tooltipHeight - 15;
        
        // Ensure tooltip stays within viewport
        tooltipX = Math.max(10, Math.min(tooltipX, this.width - tooltipWidth - 10));
        tooltipY = Math.max(10, tooltipY);
        
        // Create enhanced tooltip background with glow
        this.tooltipGroup.append("rect")
            .attr("class", "tooltip-background")
            .attr("x", tooltipX)
            .attr("y", tooltipY)
            .attr("width", tooltipWidth)
            .attr("height", tooltipHeight)
            .style("filter", "url(#glow)");
        
        // Create tooltip arrow
        const arrowSize = 8;
        const arrowX = nodeX;
        const arrowY = tooltipY + tooltipHeight;
        
        this.tooltipGroup.append("polygon")
            .attr("class", "tooltip-arrow")
            .attr("points", `${arrowX},${arrowY + arrowSize} ${arrowX - arrowSize},${arrowY} ${arrowX + arrowSize},${arrowY}`)
            .style("filter", "url(#glow)");
        
        // Create title text
        this.tooltipGroup.append("text")
            .attr("x", tooltipX + tooltipWidth / 2)
            .attr("y", tooltipY + padding + titleBBox.height)
            .style("font-weight", "bold")
            .style("font-size", "13px")
            .style("fill", "var(--text-color)")
            .text(title);
        
        // Create subtitle text only if subtitle exists
        if (subtitle) {
            this.tooltipGroup.append("text")
                .attr("x", tooltipX + tooltipWidth / 2)
                .attr("y", tooltipY + padding + titleBBox.height + lineHeight)
                .style("font-size", "11px")
                .style("opacity", "0.8")
                .style("fill", "var(--text-color)")
                .text(subtitle);
        }
        
        // Show tooltip with enhanced animation
        this.tooltipGroup.classed("visible", true);
    }
    
    hideTooltip() {
        this.tooltipGroup.classed("visible", false);
    }
    
    handleEnhancedNodeClick(event, node) {
        // Create ripple effect
        this.createRippleEffect(node.x, node.y);
        
        // Enhanced click handling
        if (node.type === 'blog_post') {
            // Navigate to blog post with smooth transition
            setTimeout(() => {
                window.open(`/b/${node.id}/`, '_blank');
            }, 200);
        } else if (node.url) {
            // Open external link
            setTimeout(() => {
                window.open(node.url, '_blank');
            }, 200);
        }
    }
    
    createRippleEffect(x, y) {
        // Create effects group if it doesn't exist
        if (!this.effectsGroup) {
            this.effectsGroup = this.g.append("g").attr("class", "effects");
        }
        
        const ripple = this.effectsGroup.append("circle")
            .attr("class", "ripple-effect")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", 0);
        
        // Animate ripple
        ripple.transition()
            .duration(1000)
            .ease(d3.easeCircleOut)
            .attr("r", 50)
            .style("opacity", 0)
            .remove();
    }
    
    highlightConnections(targetNode) {
        // Clear previous highlights
        this.clearHighlights();
        
        // Find connected nodes and links
        const connectedNodeIds = new Set();
        
        // Get the edges data from the simulation
        const edges = this.simulation ? this.simulation.force("link").links() : [];
        
        edges.forEach(edge => {
            const sourceId = edge.source.id || edge.source;
            const targetId = edge.target.id || edge.target;
            
            if (sourceId === targetNode.id || targetId === targetNode.id) {
                connectedNodeIds.add(sourceId);
                connectedNodeIds.add(targetId);
            }
        });
        
        // Highlight connected nodes
        this.node.classed("highlighted", d => connectedNodeIds.has(d.id));
        if (this.labels) {
            this.labels.classed("highlighted", d => connectedNodeIds.has(d.id));
        }
        
        // Highlight connected links
        this.link.classed("highlighted", d => {
            const sourceId = d.source.id || d.source;
            const targetId = d.target.id || d.target;
            return (sourceId === targetNode.id || targetId === targetNode.id);
        });
    }
    
    clearHighlights() {
        if (this.node) {
            this.node.classed("highlighted", false);
        }
        if (this.labels) {
            this.labels.classed("highlighted", false);
        }
        if (this.link) {
            this.link.classed("highlighted", false);
        }
    }
    
    updateLabelsVisibility() {
        if (this.labels) {
            this.labels.style("display", this.showLabels ? "block" : "none");
        }
    }
    
    updateExternalVisibility() {
        if (this.node && this.link) {
            this.node
                .style("display", d => {
                    if (d.type === 'external' && !this.showExternal) {
                        return "none";
                    }
                    return "block";
                });
            
            this.link
                .style("display", d => {
                    if (d.type === 'external' && !this.showExternal) {
                        return "none";
                    }
                    if (!this.showExternal) {
                        // Hide links to external nodes
                        const sourceExternal = d.source.type === 'external';
                        const targetExternal = d.target.type === 'external';
                        if (sourceExternal || targetExternal) {
                            return "none";
                        }
                    }
                    return "block";
                });
            
            this.labels
                .style("display", d => {
                    if (d.type === 'external' && !this.showExternal) {
                        return "none";
                    }
                    return this.showLabels ? "block" : "none";
                });
        }
    }
    
    handleResize() {
        this.width = this.container.node().clientWidth;
        this.height = this.container.node().clientHeight;
        
        this.svg.attr("viewBox", [0, 0, this.width, this.height]);
        
        if (this.simulation) {
            this.simulation
                .force("center", d3.forceCenter(this.width / 2, this.height / 2))
                .alpha(0.3)
                .restart();
        }
    }
}

// Initialize the visualization when the page loads
document.addEventListener('DOMContentLoaded', function() {
    try {
        new KnowledgeGraphVisualization();
    } catch (error) {
        console.error('Failed to initialize visualization:', error);
    }
});
</script>
{% endblock %}