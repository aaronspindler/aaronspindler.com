services:
  # PostgreSQL database for testing
  postgres:
    image: postgres:16-alpine
    environment:
      - POSTGRES_USER=test_user
      - POSTGRES_PASSWORD=test_password
      - POSTGRES_DB=test_aaronspindler
      - POSTGRES_HOST_AUTH_METHOD=trust
    ports:
      - "5433:5432"  # Use different port to avoid conflicts
    volumes:
      - postgres_test_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U test_user -d test_aaronspindler"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s
    networks:
      - test_network

  # Redis for caching and Celery broker
  redis:
    image: redis:7-alpine
    ports:
      - "6380:6379"  # Use different port to avoid conflicts
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 5s
    networks:
      - test_network

  # QuestDB for time-series data
  questdb:
    image: questdb/questdb:8.2.1
    ports:
      - "9001:9000"  # Web console (use different port to avoid conflicts)
      - "8813:8812"  # PostgreSQL wire protocol (use different port to avoid conflicts)
    environment:
      - QDB_PG_USER=test_admin
      - QDB_PG_PASSWORD=test_quest_password
      - QDB_HTTP_ENABLED=true
      - QDB_PG_ENABLED=true
      - QDB_TELEMETRY_ENABLED=false
      # Performance tuning for test environment (reduced for faster startup)
      - QDB_SHARED_WORKER_COUNT=1
      - QDB_WAL_ENABLED=true
    volumes:
      - questdb_test_data:/var/lib/questdb
    healthcheck:
      # Simple TCP connection check to PostgreSQL wire protocol port
      # Uses /dev/tcp which is available in bash (QuestDB image uses bash)
      test: ["CMD-SHELL", "bash -c '</dev/tcp/localhost/8812'"]
      interval: 3s
      timeout: 3s
      retries: 8
      start_period: 20s
    networks:
      - test_network

  # Web application (Django)
  web:
    build:
      context: ..
      dockerfile: deployment/Dockerfile.multistage
      target: runtime-full
    command: >
      sh -c "
        echo 'Waiting for services to be healthy...' &&
        while ! nc -z postgres 5432; do sleep 1; done &&
        while ! nc -z redis 6379; do sleep 1; done &&
        while ! nc -z questdb 8812; do sleep 1; done &&
        echo 'Running migrations...' &&
        python manage.py migrate --no-input &&
        echo 'Building CSS...' &&
        python manage.py build_css || true &&
        echo 'Collecting static files...' &&
        python manage.py collectstatic --no-input || true &&
        echo 'Starting test server...' &&
        python manage.py runserver 0.0.0.0:8000
      "
    volumes:
      - ..:/code
      - static_volume:/code/staticfiles
      - media_volume:/code/media
    ports:
      - "8001:8000"  # Use different port to avoid conflicts
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings_test
      - SECRET_KEY=test-secret-key-for-testing-only
      - DEBUG=True
      - DATABASE_URL=postgres://test_user:test_password@postgres:5432/test_aaronspindler
      - QUESTDB_URL=postgresql://test_admin:test_quest_password@questdb:8812/qdb
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/1
      - CELERY_RESULT_BACKEND=redis://redis:6379/2
      # Use FileSystemStorage by default (faster, no LocalStack needed)
      - USE_LOCALSTACK=false
      - TESTING_IN_DOCKER=true
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      questdb:
        condition: service_healthy
    networks:
      - test_network

  # Celery worker for background tasks
  celery_worker:
    build:
      context: ..
      dockerfile: deployment/Dockerfile.multistage
      target: runtime-full
    command: celery -A config worker -l info --concurrency=2
    volumes:
      - ..:/code
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings_test
      - SECRET_KEY=test-secret-key-for-testing-only
      - DATABASE_URL=postgres://test_user:test_password@postgres:5432/test_aaronspindler
      - QUESTDB_URL=postgresql://test_admin:test_quest_password@questdb:8812/qdb
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/1
      - CELERY_RESULT_BACKEND=redis://redis:6379/2
      - USE_LOCALSTACK=false
    depends_on:
      - postgres
      - redis
      - questdb
      - web
    networks:
      - test_network

  # Celery beat for scheduled tasks
  celery_beat:
    build:
      context: ..
      dockerfile: deployment/Dockerfile.multistage
      target: runtime-minimal
    command: celery -A config beat -l info
    volumes:
      - ..:/code
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings_test
      - SECRET_KEY=test-secret-key-for-testing-only
      - DATABASE_URL=postgres://test_user:test_password@postgres:5432/test_aaronspindler
      - QUESTDB_URL=postgresql://test_admin:test_quest_password@questdb:8812/qdb
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/1
      - CELERY_RESULT_BACKEND=redis://redis:6379/2
    depends_on:
      - postgres
      - redis
      - questdb
      - celery_worker
    networks:
      - test_network

  # Flower for monitoring Celery (optional, but useful for debugging)
  flower:
    build:
      context: ..
      dockerfile: deployment/Dockerfile.multistage
      target: runtime-minimal
    command: >
      celery -A config flower
      --port=5555
      --persistent=true
      --db=/data/flower.db
      --max_tasks=50000
      --state_save_interval=10000
    ports:
      - "5556:5555"  # Use different port to avoid conflicts
    volumes:
      - flower_data:/data
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings_test
      - SECRET_KEY=test-secret-key-for-testing-only
      - DATABASE_URL=postgres://test_user:test_password@postgres:5432/test_aaronspindler
      - CELERY_BROKER_URL=redis://redis:6379/1
      - CELERY_RESULT_BACKEND=redis://redis:6379/2
    depends_on:
      - redis
      - celery_worker
    networks:
      - test_network

  # Test runner service
  test_runner:
    build:
      context: ..
      dockerfile: deployment/Dockerfile.multistage
      target: test
    command: >
      sh -c "
        echo 'Waiting for services to be ready...' &&
        sleep 5 &&
        echo 'Running migrations...' &&
        python manage.py migrate --settings=config.settings_test --no-input &&
        echo 'Running tests...' &&
        python manage.py test --settings=config.settings_test --keepdb --verbosity=2
      "
    volumes:
      - ..:/code
      - static_volume:/code/staticfiles
      - media_volume:/code/media
    environment:
      - DJANGO_SETTINGS_MODULE=config.settings_test
      - SECRET_KEY=test-secret-key-for-testing-only
      - DEBUG=False
      - DATABASE_URL=postgres://test_user:test_password@postgres:5432/test_aaronspindler
      - QUESTDB_URL=postgresql://test_admin:test_quest_password@questdb:8812/qdb
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/1
      - CELERY_RESULT_BACKEND=redis://redis:6379/2
      # Use FileSystemStorage by default (faster, no LocalStack needed)
      # Set USE_LOCALSTACK=true to enable S3 testing with LocalStack
      - USE_LOCALSTACK=false
      - PYTHONDONTWRITEBYTECODE=1
      - PYTHONUNBUFFERED=1
      - TESTING_IN_DOCKER=true
    mem_limit: 4g
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      questdb:
        condition: service_healthy
    networks:
      - test_network
    profiles:
      - test

volumes:
  postgres_test_data:
  questdb_test_data:
  static_volume:
  media_volume:
  flower_data:

networks:
  test_network:
    driver: bridge
